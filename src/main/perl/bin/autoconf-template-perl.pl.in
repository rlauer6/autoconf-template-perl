#!/usr/bin/env perl
# -*- mode: perl; -*-

# autoconfisication of Perl applications

use strict;
use warnings;

use Autoconf::Constants qw(:all);
use Autoconf::Utils qw(:all);
use Carp qw(croak);
use Config::IniFiles;
use Cwd;
use Data::Dumper;
use Date::Format qw(time2str);
use English qw(-no_match_vars);
use File::Basename qw(basename fileparse dirname);
use File::Copy;
use File::Find;
use File::Path qw(make_path);
use File::ShareDir qw(dist_dir);
use Getopt::Long qw(:config no_ignore_case);
use JSON qw(decode_json);
use List::Util qw(any none pairs);
use Log::Log4perl qw(:easy get_logger);
use Module::ScanDeps::Static;
use Scalar::Util qw(reftype);
use Text::ASCIITable::EasyTable;
use YAML qw(LoadFile DumpFile);

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolation)

caller or __PACKAGE__->main();

########################################################################
sub main {
########################################################################

  check_for_autotools();

  my $file_list = slurp_file( $FILE_LIST, type => 'json' );

  my %options = ( file_list => $file_list );

  # options are defined with '-' to separate words to make it easy to
  # type options on CLI
  GetOptions(
    \%options,                'author=s',
    'bash!',                  'conf|C=s',
    'create-manifest|M',      'create-missing|c',
    'create-stub=s',          'destdir=s',
    'email=s',                'force',
    'help|h',                 'html|H!',
    'list-stubs|L',           'log-level|l=s',
    'manifest|m=s',           'project=s',
    'refresh|r',              'rpm-build-mode|R!',
    'rpm-install-from-cpan!', 'rpm-requires|q=s@',
    'scripts|S',              'source-dir|S',
    'unit-tests!',            'version',
  );

  return help()
    if $options{help};

  return version($VERSION)
    if $options{version};

  init_logger( $options{'log-level'} );

  $options{autoconf_templaterc} = load_autoconf_templaterc( \%options );

  set_defaults( \%options );

  return list_stubs( \%options )
    if $options{'list-stubs'};

  return create_manifest( \%options )
    if $options{'create-manifest'};

  croak 'no destination dir, '
    . "use --destdir to specify the location for the build tree\n"
    if !$options{destdir} && !$options{refresh} && !$options{'create-stub'};

  TRACE Dumper( [ 'options', \%options ] );

  my %meta_data = %options;
  delete $meta_data{autoconf_template_perlrc};

  # find manifest if not doing a refresh
  if ( !$options{refresh} && !$options{'create-stub'} ) {
    $options{manifest} ||= $MANIFEST_FILE; # check cwd for manifest.yaml

    croak "no manifest, use --manifest to specify a YAML manifest\n"
      if !-e $options{manifest};

    INFO 'loading manifest...';
    $options{manifest} = check_manifest( \%options );
  }
  else {
    @options{qw(project destdir)} = find_root_dir();

    my $meta_data_file = sprintf '%s/%s/%s', @options{qw( destdir project)},
      'project.yaml';

    %meta_data = eval {
      my $obj = LoadFile($meta_data_file);
      return %{$obj};
    };
  }

  init_parameters( \%options );

  if ( $options{'create-stub'} ) {
    create_stub( \%options );

    INFO 'refereshing project...';
    system $PROGRAM_NAME, '--refresh',
      '--log-level', $options{'log-level'} || 'info';

    return;
  }

  TRACE Dumper( [ 'options after init_parameters()', \%options ] );

  my $manifest = $options{manifest};

  if ( !$options{refresh} ) {

    # override build mode options if we have something in the manifest
    if ( $manifest->{bash} && keys %{ $manifest->{bash} } ) {
      $options{bash_build_mode} = $TRUE;
    }

    if ( $manifest->{html} && keys %{ $manifest->{html} } ) {
      $options{html_build_mode} = $TRUE;
    }

    INFO 'creating project build tree...';

    create_build_tree( \%options );

    # copy files from manifest to target directories
    INFO 'copying files to ' . $options{destdir};

    copy_files( \%options );
  }

  find_perl_modules( \%options );

  if ( !$options{refresh} ) {
    if ( $options{'unit-tests'} ) {
      INFO 'creating unit tests...';
      create_unit_tests( \%options, $options{dependencies} );
    }

    # copy extra files that do not need to be rendered, but are required
    # for the project's autoconfiscation to the project directory (see
    # resources/file_list.json)
    INFO 'copying additional files...';
    copy_list( \%options );
  }

  # * create the Perl module requirement files
  # - autotools/ax_requirements_check.m4
  # - requirements.txt
  # - requirements.json

  INFO 'finding dependencies...';
  create_requirement_files( \%options );

  set_rpm_build_options( \%options );

  # * render the templates: parameters needed are set in the %options
  #   hash.
  # * templates are listed in 'file_list.json' and
  #   'templates/Makefile.am'.
  TRACE Dumper( [ 'options before rendering', \%options ] );

  INFO 'rendering templates...';
  render_templates( \%options );

  # * create ChangeLog AFTER all files have been created in new project
  #   directory
  if ( !$options{refresh} ) {
    %meta_data = (
      %meta_data,
      project       => $options{project},
      email         => $options{email},
      author        => $options{author},
      creation_date => scalar localtime,
    );

    DumpFile( "$options{destdir}/project.yaml", \%meta_data );

    # create autotools/ax-extra-opts.m4
    system 'autoconf-ax-extra-opts', '--root', $options{destdir},
      '--no-reconf';

    INFO 're-rendering configure.ac...';
    # refresh configure.ac
    render_tt_template(
      { template   => 'configure.ac.tt',
        parameters => \%options,
        outfile    => "$options{destdir}/configure.ac",
        cleanup    => [qw(nl)],
      }
    );

    my $cwd = getcwd;

    INFO 'almost done!...running configure...';

    eval {
      chdir $options{destdir};
      system 'autoreconf', '-f', '-i';
    };

    chdir $cwd;

    INFO 'creating initial ChangeLog entries...';
    create_changelog( \%options );
  }

  return;
}

########################################################################
sub create_manifest {
########################################################################
  my ($options) = @_;

  my %files;

  my $srcdir = $options->{'source-dir'};

  my %file_types = (
    perl_modules     => ['pm'],
    perl_scripts     => ['pl'],
    bash_scripts     => ['sh'],
    html_files       => ['html'],
    css_files        => ['css'],
    image_files      => [qw(png gif jpg jpeg)],
    javascript_files => ['js'],
    config_files     => [qw(json ini cfg yaml)],
  );

  foreach my $param ( keys %file_types ) {
    $files{$param} = [];

    foreach my $type ( @{ $file_types{$param} } ) {
      push @{ $files{$param} },
        find_files_of_type( type => $type, path => $srcdir );
    }
  }

  my @all_files;

  my @exclude = map { @{ $files{$_} } } keys %files;

  push @exclude, map {"$srcdir/$_"} qw(Makefile Makefile.am Makefile.in);

  find(
    sub {
      return
        if -d $_ || any { $File::Find::name eq $_ } @exclude;

      push @all_files, $File::Find::name;
    },
    $srcdir
  );

  $files{resources} = \@all_files;

  DEBUG Dumper( [ 'files', \%files ] );

  my $manifest = render_tt_template(
    { template   => 'manifest.yaml.tt',
      parameters => { %files, %{$options} },
    }
  );

  while ( $manifest =~ s/\n\n/\n/xsm ) { }

  print {*STDOUT} $manifest;

  return;
}

########################################################################
sub create_stub {
########################################################################
  my ($options) = @_;

  my $file = $options->{'create-stub'};

  croak "no stub file specified - --create-stub filename\n"
    if !$file;

  @{$options}{qw(project destdir)} = find_root_dir();

  my %subdirs = (
    '.html' => 'src/main/html/htdocs',
    '.css'  => 'src/main/html/css',
    '.js'   => 'src/main/html/javascript',
    '.pm'   => 'src/main/perl/lib',
    '.pl'   => 'src/main/perl/bin',
    '.sh'   => 'src/main/bash/bin',
    '.cgi'  => 'src/main/perl/cgi-bin',
  );

  # get the extension so we can find a stub
  my ( $name, $path, $ext ) = fileparse( $file, qr/[.][^.]+$/xsm );

  my $target_ext = $ext eq '.cgi' ? '.pl' : $ext;

  DEBUG Dumper(
    [ project => $options->{project},
      destdir => $options->{destdir},
      file    => $file,
      name    => $name,
      path    => $path,
      ext     => $ext
    ]
  );

  my @stubs = get_stubs($options);

  for (@stubs) {
    $_->{type} =~ s/\s//gxsm;
  }

  DEBUG Dumper( [ 'ext', $ext, 'stubs', \@stubs ] );

  croak "no template for that type type ($ext)\n"
    if none { $ext eq $_->{type} } @stubs;

  my ($stub) = grep { $target_ext eq $_->{type} } @stubs;

  DEBUG Dumper( [ 'found a stub' => $stub ] );

  my %parameters = %{$options};

  $parameters{template_name} = $stub->{path};

  DEBUG Dumper( [ 'found a template' => $parameters{template_name} ] );

  # for the template - package [% module_name %];
  if ( $ext eq '.pm' ) {
    my $module_name = path_to_module($file);
    $parameters{module_name} = $module_name;
  }

  DEBUG Dumper(
    [ destdir => $options->{destdir},
      project => $options->{project},
      path    => $subdirs{$ext},
      name    => $name,
      ext     => $target_ext,
    ]
  );

  my $destdir = sprintf '%s/%s/%s/%s%s.in', $options->{destdir},
    $options->{project},
    $subdirs{$ext},
    $name, $target_ext;

  croak "$destdir already exists...use -f to force\n"
    if -e $destdir && !$options->{force};

  render_tt_template(
    { template   => $parameters{template_name},
      parameters => \%parameters,
      outfile    => $destdir,
    }
  );

  return;
}

########################################################################
sub set_rpm_build_options {
########################################################################
  my ($options) = @_;

  return
    if !$options->{'rpm-build-mode'};

  my $requires = sprintf '%s/requires.txt', $options->{destdir};

  my %rpm_options;
  $options->{rpm} = \%rpm_options;

  $rpm_options{install_cpan_files} = $options->{'rpm-install-from-cpan'};

  DEBUG Dumper(
    [ $rpm_options{install_cpan_files}, $requires, -e $requires ] );

  if ( $rpm_options{install_cpan_files} && -e $requires ) {
    my $provides = slurp_file($requires);

    $provides = [ map { ( split /\s+/xsm )[0] } split /\n/xsm, $provides ];
    $rpm_options{provides} = $provides;
  }

  $rpm_options{requires} = [qw(curl make gcc perl perl-core)];

  if ( $options->{'rpm-requires'}
    && reftype( $options->{'rpm-requires'} ) eq 'ARRAY' ) {
    push @{ $rpm_options{requires} }, @{ $options->{'rpm-requires'} };
  }

  $rpm_options{man_pages}
    = @{ $options->{perl_modules} } || @{ $options->{perl_scripts} };
  $rpm_options{perl_modules} = @{ $options->{perl_modules} } ? $TRUE : $FALSE;
  $rpm_options{bin_files} = @{ $options->{bash_scripts} } ? $TRUE : $FALSE;
  $rpm_options{bin_files} ||= @{ $options->{perl_scripts} } ? $TRUE : $FALSE;

  $rpm_options{resources}    = @{ $options->{resources} };
  $rpm_options{config_files} = @{ $options->{config} };

  $rpm_options{cgi_bin}    = @{ $options->{cgi_scripts} };
  $rpm_options{html}       = @{ $options->{html_files} };
  $rpm_options{javascript} = @{ $options->{javascript_files} };
  $rpm_options{css}        = @{ $options->{css_files} };
  $rpm_options{image}      = @{ $options->{image_files} };

  return $options;
}

########################################################################
sub set_defaults {
########################################################################
  my ($options) = @_;

  # templates that should not be rendered
  $options->{'exclude-templates'} = [];

  $options->{html}         //= $TRUE;
  $options->{bash}         //= $TRUE;
  $options->{'unit-tests'} //= $TRUE;

  $options->{html_build_mode} = delete $options->{html};
  $options->{bash_build_mode} = delete $options->{bash};

  $options->{'rpm-build-mode'}        //= $TRUE;
  $options->{'rpm-install-from-cpan'} //= $TRUE;

  if ( !$options->{'rpm-build-mode'} ) {
    push @{ $options->{exclude_templates} }, 'spec.in.tt';
  }

  # defaults
  $options->{email}        //= $ENV{EMAIL} // 'anonymouse@example.com';
  $options->{author}       //= 'Anonymouse';
  $options->{project}      //= 'noname';
  $options->{'source-dir'} //= getcwd;

  return $options;
}

########################################################################
sub help {
########################################################################
  my $name = basename $PROGRAM_NAME;

  return print <<"END_OF_HELP";
usage: $name options

Options               Arg
-------               ---- 
-h, --help                      help
-a, --author          name      author's name (default: "anonymouse")
-b, --bash                      build bash directories (default: true)
-c, --create-missing            create any files in manifest that do not exist (default: false)
-C, --create-manifest           create a manifest file from the current directory
-S, --create-stub     filename  create a stub file
-d, --destdir         directory root for project directory
-e, --email           email     author's email (default: $ENV{EMAIL} || anonymouse\@example.com)
-f, --force                     force overwrite of project directory
-h, --html                      build html directories (default: true)
-l, --log-level       level     logging level, error, warn, info, debug, trace  (default: error)
-L, --list-stubs                lists the stub templates available
-m, --manifest        filename  name of the YAML manifest file
-p, --project         name      project name (default: "noname")
-r, --refresh                   refresh after  addition of script or module
-R, --rpm-build                 enable or disable RPM spec file
-s, --source-dir      directory source directory for files in manifest or when creating manifest
                                (default: pwd)
-u, --unit-tests                create unit test stubs (default: true)
-v, --version                   report script version

These options default to true, use --no-{option} to disable

--bash
--html
--rpm-build
--unit-tests

This utility is part of the `autoconf-template-perl` toolchain. It will
create an autoconfiscated Perl application based on the description
contained in a manifest file.

See `perldoc Autoconf::Template` for more of the gory details.

$COPYRIGHT
END_OF_HELP
}

########################################################################
sub load_autoconf_templaterc {
########################################################################
  my ($options) = @_;

  my $rc_file = $options->{conf};

  if ( !$rc_file ) {
    my @paths = ( $ENV{HOME}, $PROJECT_DIR );

    eval {
      find(
        { no_chdir => $TRUE,
          wanted   => sub {
            return if !/[.]autoconf-template-perlrc/xsm;
            $rc_file = $File::Find::name;

            die 'found';
          }
        },
        @paths
      );
    };

  }

  croak "could not find your configuration file ($rc_file)\n"
    if $rc_file && !-e $rc_file;

  $options->{conf} = $rc_file;

  if ( -e "$rc_file" ) {
    $options->{autoconf_template_perlrc}
      = Config::IniFiles->new( -file => $rc_file );
  }

  return;
}

########################################################################
sub get_stubs {
########################################################################
  my ($options) = @_;

  my $config = $options->{autoconf_template_perlrc};

  my @stubs;

  foreach ( $config->Parameters('stubs') ) {
    push @stubs,
      {
      type => sprintf( '%5s', ".$_" ),
      path => $config->val( 'stubs', $_ )
      };
  }

  return @stubs;
}

########################################################################
sub list_stubs {
########################################################################
  my ($options) = @_;

  my @stubs = get_stubs($options);

  my $dist_dir = dist_dir('Autoconf-Template');

  print easy_table(
    data          => \@stubs,
    table_options => { headingText => 'Artifact Templates' },
    rows          => [ 'Type', 'type', 'Path', 'path' ],
  );

  return \@stubs;
}

########################################################################
sub check_for_autotools {
########################################################################
  for (qw(autoconf automake make)) {
    `$_ --version >/dev/null 2>&1`;
    croak "you're missing $_ or it's not your path\n"
      if $CHILD_ERROR ne '0';
  }

  return;
}

########################################################################
sub find_perl_modules {
########################################################################
  my ($options) = @_;

  # find all the Perl modules under src/main/perl/lib and create a
  # dependency tree. This will feed the perl-modules.inc.tt template
  # that creates build rules based on dependencies within the project
  # itself.
  #
  # If we want to syntactically check all Perl modules we need to
  # build modules that are dependencies of other modules first within
  # the build tree.
  #
  # 1. Find all of the Perl modules in the build tree and then call
  # get_dependencies() which uses Module::ScanDeps::Static to find
  # dependencies for each module that are satisfied locally.
  #
  # 2. Create dependency tree (more of a listing) for each module
  #
  # 3. Create an array of module names that will be used in the Makefile.am
  #
  # 4. perl-modules.inc is the rendered with all the other templates

  my $root = $options->{destdir} . '/src/main/perl/lib';
  my $dirs = get_subdirs($root);

  my $dependencies = get_dependencies($options);

  $options->{modules} = create_dependency_tree( $dirs, $dependencies, $root );

  foreach my $file ( keys %{$dependencies} ) {
    strip_in( $dependencies->{$file} );
    $dependencies->{ strip_in($file) } = $dependencies->{$file};
  }

  $options->{dependencies} = $dependencies;

  DEBUG Dumper(
    [ 'dependencies', $dependencies, 'modules', $options->{modules} ] );

  $options->{module_names} = [];

  for ( @{ $options->{modules} } ) {
    push @{ $options->{module_names} }, sprintf q{$} . q{(%sMODULES)},
      $_->{name_uc};
  }

  return $options;
}

########################################################################
sub find_local_dependencies {
########################################################################
  my ( $modules, $path ) = @_;

  my $output = {};

  for my $file ( @{$modules} ) {
    my $this = $file;
    $this =~ s/$path\///xsm;

    $output->{$this} = [];

    if ( $file !~ /[.]in$/xsm ) {
      $file = "$file.in";
    }

    my $scanner = Module::ScanDeps::Static->new(
      { core => 0,
        path => "$file",
      }
    );

    $scanner->parse;

    my @dependencies = $scanner->get_dependencies();

    DEBUG Dumper( [ 'dependencies', \@dependencies, 'modules', $modules ] );

    for my $d (@dependencies) {
      my $name = module_to_path( $d->{name} );

      TRACE 'looking for ' . $name;

      next if none {/$name/xsm} @{$modules};

      TRACE Dumper( [ $this, $name ] );

      push @{ $output->{$this} }, "$name.in";
    }

  }

  return { modules => $output };
}

########################################################################
sub get_subdirs {
########################################################################
  my ( $path, $dirs ) = @_;

  opendir my $fh, "$path"
    or croak "could not open directory: $OS_ERROR";

  while ( my $file = readdir $fh ) {

    next if $file =~ /^[t.][.]?$/xsm;

    if ( -d "$path/$file" ) {
      $dirs->{"$path/$file"} = [];
      $dirs = get_subdirs( "$path/$file", $dirs );
    }
    else {
      if ( $file =~ /[.]pm[.]in$/xsm ) {
        push @{ $dirs->{$path} }, $file;
      }
    }
  }

  closedir $fh;

  return $dirs;
}

########################################################################
sub create_build_tree {
########################################################################
  my ($options) = @_;

  my $main_prefix = sprintf '%s/src/main', $options->{destdir};

  croak "directory $main_prefix exists - use -f to force\n"
    if -d $main_prefix && !$options->{force};

  for (qw(config resources)) {
    make_path("$options->{destdir}/$_");
  }

  my $manifest = $options->{manifest};

  my @main_dirs = qw(perl);

  DEBUG Dumper( [ 'manifest', $manifest ] );

  DEBUG Dumper( [ 'build tree options', [ @{$options}{qw(bash html)} ] ] );

  for (qw(bash html)) {
    if ( $options->{ $_ . '_build_mode' } ) {
      push @main_dirs, $_;
    }
  }

  foreach (@main_dirs) {
    make_path("$main_prefix/$_");
  }

  my @perl_dirs = qw(lib bin cgi-bin);

  foreach (@perl_dirs) {
    make_path("$main_prefix/perl/$_");
  }

  my @bash_dirs;

  if ( $options->{bash_build_mode} ) {
    @bash_dirs = 'bin';

    foreach (@bash_dirs) {
      make_path("$main_prefix/bash/$_");
    }
  }

  DEBUG Dumper( [ 'dirs', \@main_dirs, \@bash_dirs, \@perl_dirs ] );

  my (@makefiles) = (
    "$options->{destdir}/src/Makefile.am"           => ['main'],
    "$options->{destdir}/src/main/Makefile.am"      => \@main_dirs,
    "$options->{destdir}/src/main/bash/Makefile.am" => \@bash_dirs,
    "$options->{destdir}/src/main/perl/Makefile.am" => \@perl_dirs,
  );

  foreach my $p ( pairs @makefiles ) {
    my ( $makefile, $subdirs ) = @{$p};
    next if !@{$subdirs};

    render_tt_template( 'Makefile.tt', { dir_list => $subdirs }, $makefile );
  }

  return;
}

########################################################################
sub _copy_files {
########################################################################
  my (%args) = @_;

  my ( $prefix, $file_list, $add_in, $options )
    = @args{qw(prefix files add_in options)};

  for my $file ( @{$file_list} ) {
    my $dest = basename $file;

    DEBUG Dumper( [ 'source ', $file, 'basename ', $dest ] );

    # .pm files, we may have a directory hierarchy that we want to
    # reflect in the build tree. IOW, for Foo/Bar/Baz.pm it needs
    # to be installed in:
    #
    #   src/main/perl/lib/Foo/Bar
    #
    # ...not src/main/perl/lib
    #
    # so use the package name to reflect the directory hierarchy
    #
    if ( $file =~ /[.]pm/xsm ) {
      $dest = find_module_filename($file);
    }

    if ( $add_in && $file !~ /[.]in$/xsm ) {
      $dest = "$dest.in";
    }

    DEBUG Dumper( [ 'creating/copying path', "$prefix/$dest" ] );

    create_path("$prefix/$dest");

    if ( -e $file ) {
      copy( $file, "$prefix/$dest" );
    }
    else {
      # see if we have a stub for this type...

      my ( $name, $path, $ext ) = fileparse( $file, qr/[.][^.]+$/xsm );

      DEBUG Dumper( [ 'creating file ', $file, $name, $path, $ext ] );

      my $stub_name = "$TEMPLATES_DIR/stub$ext.tt";

      if ( -e $stub_name ) {
        my %parameters = %{$options};
        $parameters{template_name} = $stub_name;

        DEBUG Dumper( [ 'found a template ', $stub_name ] );

        if ( $ext eq '.pm' ) {
          my $module_name = path_to_module($file);
          $parameters{module_name} = $module_name;
        }

        render_tt_template(
          { template   => $stub_name,
            parameters => \%parameters,
            outfile    => "$prefix/$dest",
          }
        );
      }
      else {
        DEBUG 'no template found for: ' . $file;

        # create empty missing file
        open my $fh, '>', "$prefix/$dest"
          or croak "could not create missing $file in $prefix/$dest\n";

        close $fh;
      }
    }
  }

  return;
}

########################################################################
sub copy_files {
########################################################################
  my ($options) = @_;

  my $manifest = $options->{manifest};

  _copy_files(
    prefix  => $options->{destdir} . '/resources',
    files   => $manifest->{resources},
    add_in  => $FALSE,
    options => $options,
  );

  _copy_files(
    prefix  => $options->{destdir} . '/config',
    files   => $manifest->{config},
    add_in  => $TRUE,
    options => $options,
  );

  my $main_prefix = sprintf '%s/src/main', $options->{destdir};

  for (qw(lib cgi-bin bin)) {
    _copy_files(
      prefix  => "$main_prefix/perl/$_",
      files   => $manifest->{perl}->{$_},
      add_in  => $TRUE,
      options => $options,
    );
  }

  _copy_files(
    prefix  => "$main_prefix/bash/bin",
    files   => $manifest->{bash}->{bin},
    add_in  => $TRUE,
    options => $options,
  );

  # create the directory structure and 'Makefile.am' even
  # if we don't have files if html is include it the manifest
  if ( $manifest->{html} ) {
    for (qw(htdocs javascript css image)) {
      _copy_files(
        prefix  => "$main_prefix/html/$_",
        files   => $manifest->{html}->{$_},
        add_in  => $FALSE,
        options => $options,
      );
    }
  }

  return;
}

########################################################################
sub make_absolute {
########################################################################
  my ( $srcdir, $file ) = @_;

  return $file if $file =~ /\//xsm;

  return "$srcdir/$file";
}

########################################################################
sub check_manifest {
########################################################################
  my ($options) = @_;

  my $manifest = eval { LoadFile( $options->{manifest} ); };

  # manifest overrides other parameters
  foreach (qw(project email description author)) {
    $options->{$_} = $manifest->{$_};
  }

  if ( !$manifest || $EVAL_ERROR ) {
    croak "could not load manifest file: $EVAL_ERROR\n";
  }

  my $srcdir = $options->{'source-dir'};

  # check manifest
  for (qw(config resources)) {
    next if !$manifest->{$_};

    for my $file ( @{ $manifest->{$_} } ) {
      $file = expand_filename($file);

      croak "$file does not exist"
        if !-e $file && !$options->{'create-missing'};

      $file = make_absolute( $srcdir, $file );
    }
  }

  for my $dir (qw(bin cgi-bin lib)) {
    next if !$manifest->{perl}->{$dir};

    for my $file ( @{ $manifest->{perl}->{$dir} } ) {
      $file = expand_filename($file);

      croak "$file does not exist"
        if !-e $file && !$options->{'create-missing'};

      # only make files that exist absolute, otherwise we won't create
      # package name correctly
      next if $dir eq 'lib' && !-e $file;

      $file = make_absolute( $srcdir, $file );
    }
  }

  if ( $manifest->{config} ) {
    foreach my $file ( @{ $manifest->{config} } ) {
      INFO 'config: ' . $file;
      $file = expand_filename($file);

      croak sprintf "config files should have extensions of %s\n",
        join $COMMA, values %CONFIG_FILE_EXTENSIONS
        if none { $file =~ /[.]$_$/xsm } values %CONFIG_FILE_EXTENSIONS;

      $file = make_absolute( $srcdir, $file );
    }
  }

  return $manifest;
}

########################################################################
sub get_dependencies {
########################################################################
  my ($options) = @_;

  my $root = $options->{destdir} . '/src/main/perl/lib';

  my @perl_modules;

  croak q{this doesn't look much like a project directory}
    if !-d $root;

  @perl_modules = find_files( $root, 'pm', $FALSE );

  my $dirs = get_subdirs($root);

  my $all_dependencies
    = eval { return find_local_dependencies( [@perl_modules], $root ); };

  croak "error gathering dependencies: $EVAL_ERROR"
    if !$all_dependencies || $EVAL_ERROR;

  DEBUG Dumper( [ 'dependencies', $all_dependencies ] );

  return $all_dependencies->{modules};
}

########################################################################
sub makefile_am_list {
########################################################################
  my ( $file_list, $dir ) = @_;

  return $EMPTY if !ref $file_list || !@{$file_list};

  my @files = @{$file_list};

  if ($dir) {
    @files = map {"$dir/$_"} @files;
  }

  my $list = join " \\\n    ", @files;

  return "\\\n    " . $list;
}

########################################################################
sub find_resources {
########################################################################
  my ($root) = @_;

  my @resources;

  find(
    sub {
      return if /^Makefile/xsm || -d $File::Find::name;

      push @resources, basename $File::Find::name;
    },
    "$root/resources"
  );

  return \@resources;
}

########################################################################
sub init_parameters {
########################################################################
  my ($options) = @_;

  my @now = localtime;
  $now[5] += 1900;
  $now[4] += 1;

  my %timestamp = timestamp();

  $options->{date}      = $timestamp{date};
  $options->{timestamp} = $timestamp{timestamp};

  # Fri Feb 10 14:16:12 2023
  $options->{version}   = '@PACKAGE_VERSION@';   ## no critic (RequireInterpolation)
  $options->{generator} = basename $PROGRAM_NAME;

  # convenience routines for TT
  # creates a list that looks like this:
  # FOO = \
  #     ITEM \
  #     ITEM \
  #     ITEM
  $options->{makefile_am_list} = \&makefile_am_list;

  if ( $options->{refresh} ) {
    # main() prepped 'destdir', 'project' for refresh option from
    # abs_top_srcdir in Makefile, so we should be certain that root
    # for refresh is correct...
    my $root = sprintf '%s/%s', $options->{destdir}, $options->{project};

    $options->{resources} = find_resources($root);

    # refresh the list of files for 'built' assets look for .in files
    # in each directory, presumably someone dropped a new .in file in
    # one of these and wants to refresh the Makefile.am

    my %html_files = (
      html       => [ 'htdocs',     ['html'] ],
      javascript => [ 'javascript', ['js'] ],
      css        => [ 'css',        ['css'] ],
      image      => [ 'image',      [qw(png gif jpeg jpg)] ],
    );

    foreach ( keys %html_files ) {
      my $file_list = $_ . '_files';

      $options->{$file_list} = [];

      my ( $subdir, $ext_list ) = @{ $html_files{$_} };

      foreach my $file_type ( @{$ext_list} ) {
        push @{ $options->{$file_list} },
          find_files_of_type(
          path => "$root/src/main/html/$subdir",
          type => $file_type,
          );
      }
    }

    $options->{bash_scripts}
      = [ find_files( "$root/src/main/bash/bin", 'sh', $TRUE ) ];

    $options->{perl_scripts}
      = [ find_files( "$root/src/main/perl/bin", 'pl', $TRUE ) ];

    $options->{cgi_scripts}
      = [ find_files( "$root/src/main/perl/cgi-bin", 'pl', $TRUE ) ];

    $options->{perl_modules}
      = [ find_files( "$root/src/main/perl/lib", 'pm', $TRUE ) ];

    $options->{perl_modules}
      = [ map { find_module_filename($_) . '.in' }
        basename @{ $options->{perl_modules} } ];

    DEBUG Dumper(
      [ 'refreshing',
        bash_scripts => $options->{bash_scripts},
        perl_scripts => $options->{perl_scripts},
        perl_modules => $options->{perl_modules},
        cgi_scripts  => $options->{cgi_scripts},
        resources    => $options->{resources},
      ]
    );

    for my $script_type (qw(bash perl cgi)) {
      $options->{ $script_type . '_scripts' }
        = [ map { ( basename $_) . '.in' }
          @{ $options->{ $script_type . '_scripts' } } ];
    }

    DEBUG Dumper(
      [ 'refreshed',
        bash_scripts => $options->{bash_scripts},
        perl_scripts => $options->{perl_scripts},
        perl_modules => $options->{perl_modules},
        cgi_scripts  => $options->{cgi_scripts},
        resources    => $options->{resources},
      ]
    );

    # find all config files...we may have a new file here too
    my @config_files;

    foreach ( values %CONFIG_FILE_EXTENSIONS ) {
      push @config_files, find_files( "$root/config", $_, $TRUE );
    }

    $options->{config} = [@config_files];

    init_config_sections( $options, \@config_files );

    DEBUG Dumper( [ 'config sections', \@config_files, $options ] );
  }
  else {
    my $manifest = $options->{manifest};

    $options->{author}  //= $manifest->{author};
    $options->{email}   //= $manifest->{email};
    $options->{project} //= $manifest->{project};

    $options->{description} = $manifest->{description};

    my @build_file_lists = (
      bash_scripts => $manifest->{bash}->{bin},
      perl_scripts => $manifest->{perl}->{bin},
      cgi_scripts  => $manifest->{perl}->{'cgi-bin'},
    );

    # config files should technically be above list, but we add .in to
    # those files in init_config_sections
    my @file_lists = (
      html_files       => $manifest->{html}->{htdocs},
      javascript_files => $manifest->{html}->{javascript},
      css_files        => $manifest->{html}->{css},
      image_files      => $manifest->{html}->{image},
      resources        => $manifest->{resources},
      config           => $manifest->{config},
    );

    create_target_file_list( $options, \@build_file_lists, '.in' );

    create_target_file_list( $options, \@file_lists );

    $options->{perl_modules}
      = [ map { find_module_filename($_) } @{ $manifest->{perl}->{lib} } ];

    # create arrays for each config files type that will be used in
    # the config/Makefile.am template ('ini_files', 'cfg_files', etc)
    init_config_sections( $options, $options->{manifest}->{config} );
  }

  $options->{destdir} = sprintf '%s/%s', @{$options}{qw(destdir project)};

  return $options;
}

# remove path info and possibly add '.in' for files to be built
########################################################################
sub create_target_file_list {
########################################################################
  my ( $options, $file_list, $ext ) = @_;

  $ext //= $EMPTY;

  # create arrays of just the file names from the source files
  for my $p ( pairs @{$file_list} ) {
    my ( $var, $list ) = @{$p};

    $list ||= [];

    $options->{$var} = [ map { basename($_) . $ext } @{$list} ];
  }

  return $options;
}

########################################################################
sub init_config_sections {
########################################################################
  my ( $options, $configs ) = @_;

  return $options
    if !ref $configs || !@{$configs};

  # find files of type .ini, .cfg, .json, .yaml and create a
  # parameter in the options hash for each type to be used by the
  # 'config/Makefile.am.tt' template
  #
  # [% ini_files %], e.g.
  #
  foreach my $p ( pairs %CONFIG_FILE_EXTENSIONS ) {
    my ( $type, $ext ) = @{$p};

    my @config_files = grep {/[.]$ext$/xsm} @{$configs};

    foreach (@config_files) {
      s/$/.in/xsm;
    }

    $options->{$type} = [ map { basename $_ } @config_files ];
  }

  return $options;
}

########################################################################
sub render_templates {
########################################################################
  my ($parameters) = @_;

  my $file_list = $parameters->{file_list};
  my $templates = $file_list->{templates};

  my $exclude_templates = $parameters->{exclude_templates};

  for my $template ( keys %{$templates} ) {
    TRACE 'next template: ' . $template;

    next if any { $template eq $_ } @{$exclude_templates};

    if ( $parameters->{refresh} ) {
      TRACE 'refresh mode: checking against refresh list';
      next if none { $template eq $_ } @{ $file_list->{refresh} };
    }

    my ( $mode, $out, $cleanup );

    if ( ref $templates->{$template} ) {
      ( $mode, $out, $cleanup ) = @{ $templates->{$template} };
    }
    else {
      ( $mode, $out ) = ( undef, $templates->{$template} );
    }

    $out = sprintf '%s/%s', $parameters->{destdir}, $out;

    # resolve any variables in file names (@project@.spec.in), e.g.
    $out = do_subst( $out, $parameters );

    render_tt_template(
      { template   => $template,
        parameters => $parameters,
        outfile    => $out,
        cleanup    => $cleanup,
      }
    );

    TRACE sprintf 'setting permissions of  %s to %s', $out, $mode // $EMPTY;

    if ( defined $mode && $mode ) {
      chmod oct($mode), $out;
    }
  }

  return;
}

########################################################################
sub create_unit_tests {
########################################################################
  my ( $options, $dependencies ) = @_;

  # create unit test scaffolding for .pm, .pl, and .cgi files
  my @unit_tests = (
    ( sprintf '%s/%s', $options->{destdir}, 'src/main/perl/lib' ) =>
      [ 'pm', $options->{perl_modules} ],
    ( sprintf '%s/%s', $options->{destdir}, 'src/main/perl/bin' ) =>
      [ 'pl', $options->{perl_scripts} ],
    ( sprintf '%s/%s', $options->{destdir}, 'src/main/perl/cgi-bin' ) =>
      [ 'cgi', $options->{cgi_scripts} ],
  );

  for my $p ( pairs @unit_tests ) {
    my ( $path, $test_info ) = @{$p};

    my ( $ext, $files ) = @{$test_info};

    TRACE Dumper( [ 'creating unit tests ', $path, $files ] );

    next if !$files || !@{$files};

    create_unit_test_stub(
      files   => $files,
      path    => $path,
      options => $options,
      ext     => $ext,
    );
  }

  return $options;
}

########################################################################
sub create_unit_test_stub {
########################################################################
  my (%args) = @_;

  my ( $files, $path, $options, $ext ) = @args{qw(files path options ext)};

  TRACE Dumper( [ 'unit tests', $files, 'path', $path ] );

  foreach ( @{$files} ) {
    if (/[.]pm/xsm) {
      create_module_test_stub( path => $path, file => $_ );

      $options->{unit_tests}->{$ext} = create_unit_test_list( 'pm', $files );
    }
    elsif (/[.]pl/xsm) {
      create_script_test_stub( path => $path, file => $_ );

      $options->{unit_tests}->{$ext} = create_unit_test_list( 'pl', $files );
    }
  }

  return;
}

########################################################################
sub create_module_test_stub {
########################################################################
  my (%args) = @_;

  my ( $path, $file ) = @args{qw(path file)};

  my $module_name = path_to_module($file);

  my $test_name = lc $module_name;
  $test_name =~ s/::/-/xsmg;

  my $unit_test = sprintf '%s/t/00-%s.t', $path, $test_name;

  TRACE sprintf 'rendering module unit test %s to %s', $module_name,
    $unit_test;

  return render_tt_template( '00-module.t.tt', { module => $module_name },
    $unit_test );
}

########################################################################
sub create_script_test_stub {
########################################################################
  my (%args) = @_;

  my ( $file, $path ) = @args{qw(file path)};

  $file = basename $file;
  $file =~ s/[.]pl([.]in)?$//xsm;

  my $unit_test = sprintf '%s/t/00-%s.t', $path, $file;

  TRACE sprintf 'rendering script unit test %s to %s', $file, $unit_test;

  return render_tt_template( '00-script.t.tt', { script => $file },
    $unit_test );
}

########################################################################
sub create_unit_test_list {
########################################################################
  my ( $type, $files ) = @_;

  # note: do not alter input
  my @files = @{$files};

  foreach my $file (@files) {
    if ( $type =~ /pm/xsm ) {
      $file = lc $file;
      $file =~ s/\//-/gxsm;
    }

    $file =~ s/[.]$type([.]in)?/.t/xsm;
    $file = "t/00-$file";
  }

  return [@files];
}

########################################################################
sub create_requirement_files {
########################################################################
  my ($options) = @_;

  my $m4_macro = sprintf '%s/autotools/ax_requirements_check.m4',
    $options->{destdir};

  my $requirements_text = sprintf '%s/requires.txt',  $options->{destdir};
  my $requirements_json = sprintf '%s/requires.json', $options->{destdir};

  my %outfiles = (
    m4   => $m4_macro,
    text => $requirements_text,
    json => $requirements_json,
  );

  ## no critic (RequireInterpolationOfMetachars)
  my @ax_requirements_check = '@bindir@/autoconf-ax-requirements-check';

  # set rootdir option
  push @ax_requirements_check, '-r', $options->{destdir};

  # pass along log-level
  push @ax_requirements_check, '-l', $options->{'log-level'} // 'info';

  # create the JSON file first
  system @ax_requirements_check, '-o', $outfiles{'json'}, '-f', 'json';

  # create requirements file for each format using JSON file as input
  for my $format (qw( text m4 )) {
    system @ax_requirements_check, '-o', $outfiles{$format}, '-f', $format,
      '-i', $outfiles{'json'};
  }

  return;
}

########################################################################
sub create_changelog {
########################################################################
  my ($options) = @_;

  my @all_files;

  find(
    sub {
      return if -d $_;
      push @all_files, $File::Find::name;
    },
    $options->{destdir}
  );

  for (@all_files) {
    s/^\/?$options->{destdir}\///xsm;
  }

  render_tt_template(
    'ChangeLog.tt',
    { %{$options}, files => [ sort { lc $a cmp lc $b } @all_files ] },
    sprintf '%s/%s',
    $options->{destdir}, 'ChangeLog'
  );

  return;
}

########################################################################
sub do_subst {
########################################################################
  my ( $arg, $parameters ) = @_;

  TRACE "do_subst($arg)";

  while ( $arg =~ /\@([^\@]+)\@/xsm ) {
    TRACE "found substitution var $1";

    die "$1 is not defined in your parameter list\n"
      if !exists $parameters->{$1};

    my $val = $parameters->{$1};
    $arg =~ s/\@$1\@/$val/xsmg;

    TRACE "arg now [$arg]";
  }

  return $arg;
}

########################################################################
sub copy_list {
########################################################################
  my ($options) = @_;

  my $destdir   = $options->{destdir};
  my $file_list = $options->{file_list}->{files};

  foreach my $file ( keys %{$file_list} ) {
    my $dest = $destdir;

    my ( $mode, $out )
      = ref $file_list->{$file}
      ? @{ $file_list->{$file} }
      : ( undef, $file_list->{$file} );

    $out ||= $file;
    $out = do_subst( $out, $options );

    if ( $out =~ /\/$/xsm ) {
      $dest = sprintf '%s/%s/%s', $destdir, $out, $file;
    }
    else {
      $dest = sprintf '%s/%s', $destdir, $out;
    }

    create_path($dest);

    TRACE sprintf 'copying %s to %s', "$PROJECT_DIR/$file", $dest;

    croak "missing $file - perhaps you forgot to add it to Makefile.am?\n"
      if !-e "$PROJECT_DIR/$file";

    copy( "$PROJECT_DIR/$file", $dest );

    if ( defined $mode ) {
      TRACE sprintf 'chmod %s, %s', $mode, $dest;
      chmod oct($mode), $dest;
    }
  }

  return;
}

########################################################################
sub create_dependency_tree {
########################################################################
  my ( $dirs, $all_dependencies, $root ) = @_;

  my @modules;

  foreach my $dir ( sort keys %{$dirs} ) {
    my %module;

    my $path = $dir;
    $path =~ s{$root/?}{}xsm;

    $module{path} = $path;

    my $list = $dirs->{$dir};

    $module{list} = [];

    foreach my $file ( @{$list} ) {
      push @{ $module{list} }, $path ? "$path/$file" : $file;
    }

    my $module_name = $path;
    $module_name =~ s/\///xsm;
    $module{name_uc} = uc $module_name || 'PERL';
    $module{name_lc} = lc $module_name;

    $module{files}        = $list;
    $module{dependencies} = {};

    foreach my $file ( @{$list} ) {
      my $dependencies = [];

      DEBUG 'looking for ' . $path . $SLASH . $file;

      my $dep_file = $path . $SLASH . $file;
      $dep_file = strip_in($dep_file);
      $dep_file =~ s/^\///xsm;

      my @local_dependencies
        = @{ $all_dependencies->{$dep_file} || [] };

      next if !@local_dependencies;

      for my $dependency (@local_dependencies) {
        $dependency = strip_in($dependency);
        push @{$dependencies}, $dependency;
      }

      $module{dependencies}->{$file} = $dependencies;
    }

    push @modules, \%module;
  }

  return \@modules;
}

1;

__END__
