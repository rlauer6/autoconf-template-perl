#!/usr/bin/env perl
# -*- mode: perl; -*-

# autoconfisication of Perl applications

use strict;
use warnings;

use Autoconf::Template::Constants qw(:all);
use Autoconf::Template::Utils qw(:all);
use Autoconf::Template::UnitTests;

use Capture::Tiny qw(capture);
use Carp qw(croak);
use Config::IniFiles;
use Cwd;
use Data::Dumper;
use Date::Format qw(time2str);
use English qw(-no_match_vars);
use File::Basename qw(basename fileparse dirname);
use File::Copy;
use File::Find;
use File::Path qw(make_path);
use File::ShareDir qw(dist_dir);
use Getopt::Long qw(:config no_ignore_case);
use JSON qw(decode_json);
use List::Util qw(any none pairs);
use Log::Log4perl qw(:easy get_logger);
use Module::ScanDeps::Static;
use Scalar::Util qw(reftype);
use Text::ASCIITable::EasyTable;
use YAML qw(LoadFile DumpFile);

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolation)

caller or __PACKAGE__->main();

########################################################################
sub main {
########################################################################

  check_for_autotools();

  my $file_list = slurp_file( $FILE_LIST, type => 'json' );

  my %options = ( file_list => $file_list );

  # options are defined with '-' to separate words to make it easy to
  # type options on CLI
  GetOptions(
    \%options,              'author=s',
    'bash!',                'conf|C=s',
    'create-manifest|M',    'create-missing|c',
    'create-test-stub|t=s', 'create-stub=s',
    'destdir=s',            'email=s',
    'force',                'help|h',
    'html|H!',              'list-stubs|L',
    'log-level|l=s',        'manifest|m=s',
    'project=s',            'project-root|P=s',
    'quiet|Q',              'refresh|r',
    'rpm-build-mode|R!',    'rpm-install-from-cpan!',
    'rpm-requires|q=s@',    'scripts|S',
    'source-dir|S',         'unit-tests!',
    'version',
  );

  $options{'log-level'} //= 'info';

  init_logger( $options{'log-level'} );

  $options{autoconf_templaterc} = load_autoconf_templaterc( \%options );

  set_defaults( \%options );

  return help()
    if $options{help};

  return version($VERSION)
    if $options{version};

  return list_stubs( \%options )
    if $options{'list-stubs'};

  return create_manifest( \%options )
    if $options{'create-manifest'};

  croak 'no destination dir, '
    . "use --destdir to specify the location of your project directory\n"
    if !$options{destdir}
    && !$options{refresh}
    && !$options{'create-stub'}
    && !$options{'create-test-stub'};

  TRACE Dumper( [ 'options', \%options ] );

  my %meta_data = %options;

  delete $meta_data{autoconf_template_perlrc};

  # find manifest if not doing a refresh
  if ( !$options{refresh}
    && !$options{'create-stub'}
    && !$options{'create-test-stub'} ) {
    $options{manifest} ||= $MANIFEST_FILE; # check cwd for manifest.yaml

    croak "no manifest, use --manifest to specify a YAML manifest\n"
      if !-e $options{manifest};

    INFO 'loading manifest...';
    $options{manifest} = check_manifest( \%options );
  }
  else {
    @options{qw(project destdir)} = find_root_dir( \%options );

    %meta_data = get_project_meta_data( \%options );
  }

  $options{root} = sprintf '%s/%s', $options{destdir}, $options{project};

  init_parameters( \%options );

  if ( $options{'create-stub'} || $options{'create-test-stub'} ) {

    create_stub( \%options );

    INFO '...refreshing project';

    my @args = ( '-r', '-P', $options{root}, '-l', $options{'log-level'} );
    system $PROGRAM_NAME, @args;

    return;
  }

  TRACE Dumper( [ 'options after init_parameters()', \%options ] );

  my $manifest = $options{manifest};

  # override build mode options if we have something in the manifest
  if ( $manifest->{bash} && keys %{ $manifest->{bash} } ) {
    $options{bash_build_mode} = $TRUE;
  }

  if ( $manifest->{html} && keys %{ $manifest->{html} } ) {
    if ( !$options{html_build_mode} ) {
      WARN
        q{you have an 'html' section in your manifest, adding a web assets};
      $options{html_build_mode} = $TRUE;
    }
  }

  INFO '...creating/refreshing project build tree';

  create_source_tree( \%options );

  if ( !$options{refresh} ) {
    # copy files from manifest to target directories
    INFO 'copying files to ' . $options{root};

    copy_files( \%options );
  }
  else {
    # don't refresh these if they don't exist
    $options{bash_build_mode} = -d sprintf '%s/src/main/bash', $options{root};
    $options{html_build_mode} = -d sprintf '%s/src/main/html', $options{root};
  }

  find_perl_modules( \%options );

  if ( $options{'unit-tests'} ) {
    INFO '...creating unit tests';

    create_unit_tests( \%options );

    INFO '...finding unit-tests';

    create_unit_tests_list( \%options );
  }

  if ( !$options{refresh} ) {
    # copy extra files that do not need to be rendered, but are required
    # for the project's autoconfiscation to the project directory (see
    # resources/file_list.json)

    INFO '...copying additional files';

    copy_list( \%options );
  }

  # * create the Perl module requirement files
  # - autotools/ax_requirements_check.m4
  # - requirements.txt
  # - requirements.json

  INFO '...finding dependencies';

  create_requirement_files( \%options );

  set_rpm_build_options( \%options );

  TRACE Dumper( [ options => \%options ] );

  $options{exclude_templates} = [];

  if ( !$options{bash_build_mode} ) {
    push @{ $options{exclude_templates} }, 'bash/bin/Makefile.am.tt';
    push @{ $options{exclude_templates} }, 'bash/Makefile.am.tt';
  }

  if ( !$options{html_build_mode} ) {
    push @{ $options{exclude_templates} }, 'html/Makefile.am.tt';
    push @{ $options{exclude_templates} }, 'perl/cgi-bin/Makefile.am.tt';
  }

  INFO '...rendering templates';

  render_templates( \%options );

  if ( !$options{refresh} ) {
    %meta_data = (
      %meta_data,
      project       => $options{project},
      email         => $options{email},
      author        => $options{author},
      creation_date => scalar localtime,
    );

    DumpFile( sprintf( '%s/project.yaml', $options{root} ), \%meta_data );

    # create autotools/ax-extra-opts.m4 for first time

    system 'autoconf-ax-extra-opts', '--root', $options{root}, '--no-reconf';

    INFO '...re-rendering configure.ac';

    render_tt_template(
      { template   => 'configure.ac.tt',
        parameters => \%options,
        outfile    => "$options{root}/configure.ac",
        cleanup    => [qw(nl)],
      }
    );

    my $cwd = getcwd;

    eval {
      chdir $options{root};

      my ( $stdout, $stderr, $exit ) = capture {
        system 'autoreconf', '-f', '-i';
      };
    };

    chdir $cwd;

    INFO '...creating initial ChangeLog entries';

    # create ChangeLog AFTER files are created in new project directory
    create_changelog( \%options );
  }

  return;
}

########################################################################
sub create_manifest {
########################################################################
  my ($options) = @_;

  my %files;

  my $srcdir = $options->{'source-dir'};

  my %file_types = (
    perl_modules     => ['pm'],
    perl_scripts     => ['pl'],
    bash_scripts     => ['sh'],
    html_files       => ['html'],
    css_files        => ['css'],
    image_files      => [qw(png gif jpg jpeg)],
    javascript_files => ['js'],
    config_files     => [qw(json ini cfg yaml)],
  );

  foreach my $param ( keys %file_types ) {
    $files{$param} = [];

    foreach my $type ( @{ $file_types{$param} } ) {
      push @{ $files{$param} },
        find_files_of_type( type => $type, path => $srcdir );
    }
  }

  my @all_files;

  my @exclude = map { @{ $files{$_} } } keys %files;

  push @exclude, map {"$srcdir/$_"} qw(Makefile Makefile.am Makefile.in);

  find(
    sub {
      return
        if -d $_ || any { $File::Find::name eq $_ } @exclude;

      push @all_files, $File::Find::name;
    },
    $srcdir
  );

  $files{resources} = \@all_files;

  DEBUG Dumper( [ files => \%files ] );

  my $manifest = render_tt_template(
    { template   => 'manifest.yaml.tt',
      parameters => { %files, %{$options} },
    }
  );

  while ( $manifest =~ s/\n\n/\n/xsm ) { }

  print {*STDOUT} $manifest;

  return;
}

########################################################################
sub create_stub {
########################################################################
  my ($options) = @_;

  my $file = $options->{'create-stub'} || $options->{'create-test-stub'};

  croak "no stub file specified - --create-stub filename\n"
    if !$file;

  if ( $options->{'create-test-stub'} ) {

    my ($path) = get_subdir_by_type($file);

    my $next_test = get_next_test_number($options);

    create_unit_test_stub(
      files       => [$file],
      path        => $path,
      test_number => $next_test,
    );
  }
  else {
    create_stub_file($options);
  }

  return;
}

########################################################################
sub get_next_test_number {
########################################################################
  my ($options) = @_;

  my $file = $options->{'create-test-stub'};

  my $ext;

  if ( $file =~ /[.](.*)([.]in)?$/xsm ) {
    $ext = $1;
  }

  my $name = flatten_filename($file);

  my $unit_tests = create_unit_tests_list($options);

  my @tests = grep {/\d{2}\-$name/xsm} @{ $unit_tests->{$ext} };

  @tests = sort map { /(\d{2})\-/xsm ? $1 : () } @tests;

  DEBUG Dumper(
    [ name       => $name,
      unit_tests => $unit_tests,
      tests      => \@tests
    ]
  );

  return @tests ? $tests[-1] + 1 : 0;
}

########################################################################
sub create_stub_file {
########################################################################
  my ($options) = @_;

  my $file = $options->{'create-stub'};

  my ( $path, $ext ) = get_subdir_by_type($file);

  my $target_ext = $ext eq '.cgi' ? '.pl' : $ext;

  my @stubs = get_stubs($options);

  TRACE Dumper(
    [ project => $options->{project},
      destdir => $options->{destdir},
      file    => $file,
      path    => $path,
      ext     => $ext,
      stubs   => \@stubs,
    ]
  );

  for (@stubs) {
    $_->{type} =~ s/\s//gxsm;
  }

  croak "no template for that type type ($ext)\n"
    if none { $ext eq $_->{type} } @stubs;

  my ($stub) = grep { $target_ext eq $_->{type} } @stubs;

  my %parameters = %{$options};

  $parameters{template_name} = $stub->{path};

  DEBUG Dumper(
    [ 'found a stub' => $stub,
      template       => $parameters{template_name}
    ]
  );

  my $name;

  # for the template - package [% module_name %];
  if ( $ext eq '.pm' ) {
    my $module_name = path_to_module($file);
    $parameters{module_name} = $module_name;
    $name = find_module_filename($file);
  }
  else {
    $name = basename($file);
  }

  $name =~ s/[.].*$//xsm;

  my $dest_path = sprintf '%s/%s/%s%s', $options->{root},
    $path, $name, $target_ext;

  # only "built" files get .in extension...
  if ( any { $ext eq $_ } qw(pl pm yaml cfg json ini) ) {
    $dest_path .= '.in';
  }

  croak "$dest_path already exists...use -f to force\n"
    if -e $dest_path && !$options->{force} && !$options->{refresh};

  render_tt_template(
    { template   => $parameters{template_name},
      parameters => \%parameters,
      outfile    => $dest_path,
    }
  );

  return;
}

########################################################################
sub set_rpm_build_options {
########################################################################
  my ($options) = @_;

  return
    if !$options->{'rpm-build-mode'};

  my $requires = sprintf '%s/requires.txt', $options->{root};

  my %rpm_options;
  $options->{rpm} = \%rpm_options;

  $rpm_options{install_cpan_files} = $options->{'rpm-install-from-cpan'};

  DEBUG Dumper(
    [ $rpm_options{install_cpan_files}, $requires, -e $requires ] );

  if ( $rpm_options{install_cpan_files} && -e $requires ) {
    my $provides = slurp_file($requires);

    $provides = [ map { ( split /\s+/xsm )[0] } split /\n/xsm, $provides ];
    $rpm_options{provides} = $provides;
  }

  $rpm_options{requires} = [qw(curl make gcc perl perl-core)];

  if ( $options->{'rpm-requires'}
    && reftype( $options->{'rpm-requires'} ) eq 'ARRAY' ) {
    push @{ $rpm_options{requires} }, @{ $options->{'rpm-requires'} };
  }

  $rpm_options{man_pages}
    = @{ $options->{perl_modules} } || @{ $options->{perl_scripts} };
  $rpm_options{perl_modules} = @{ $options->{perl_modules} } ? $TRUE : $FALSE;
  $rpm_options{bin_files} = @{ $options->{bash_scripts} } ? $TRUE : $FALSE;
  $rpm_options{bin_files} ||= @{ $options->{perl_scripts} } ? $TRUE : $FALSE;

  $rpm_options{resources}    = @{ $options->{resources} };
  $rpm_options{config_files} = @{ $options->{config} };

  $rpm_options{cgi_bin}    = @{ $options->{cgi_scripts} };
  $rpm_options{html}       = @{ $options->{html_files} };
  $rpm_options{javascript} = @{ $options->{javascript_files} };
  $rpm_options{css}        = @{ $options->{css_files} };
  $rpm_options{image}      = @{ $options->{image_files} };

  return $options;
}

########################################################################
sub set_defaults {
########################################################################
  my ($options) = @_;

  # templates that should not be rendered
  $options->{'exclude-templates'} = [];

  $options->{html}         //= $TRUE;
  $options->{bash}         //= $TRUE;
  $options->{'unit-tests'} //= $TRUE;

  $options->{html_build_mode} = delete $options->{html};
  $options->{bash_build_mode} = delete $options->{bash};

  $options->{'rpm-build-mode'}        //= $TRUE;
  $options->{'rpm-install-from-cpan'} //= $TRUE;

  if ( !$options->{'rpm-build-mode'} ) {
    push @{ $options->{exclude_templates} }, 'spec.in.tt';
  }

  # defaults
  $options->{email}        //= $ENV{EMAIL} // 'anonymouse@example.com';
  $options->{author}       //= 'Anonymouse';
  $options->{project}      //= 'noname';
  $options->{'source-dir'} //= getcwd;

  for (qw(destdir project-root source-dir)) {
    if ( $options->{$_} && $options->{$_} eq $DOT ) {
      $options->{$_} = getcwd;
    }
  }

  DEBUG Dumper( [ 'options', $options ] );

  return $options;
}

########################################################################
sub help {
########################################################################
  my $name = basename $PROGRAM_NAME;

  return print <<"END_OF_HELP";
usage: $name options

Options                Arg        Description
-------                ----       ------------
-h, --help                        help
-a, --author           name       author's name (default: "anonymouse")
-b, --bash                        build bash directories (default: true)
-c, --create-missing              create any files in manifest that do not exist (default: false)
-C, --create-manifest             create a manifest file from the current directory
-S, --create-stub      filename   create a stub file
-t, --create-test-stub filename   create a stub unit test file
-d, --destdir          directory  directory where project will be built
-e, --email            email      author's email (default: $ENV{EMAIL} || anonymouse\@example.com)
-f, --force                       force overwrite of project directory
-h, --html                        build html directories (default: true)
-l, --log-level        level      logging level, error, warn, info, debug, trace  (default: error)
-L, --list-stubs                  lists the stub templates available
-m, --manifest         filename   name of the YAML manifest file
-p, --project          name       project name (default: "noname")
-P, --project-root                root directory of project
-Q, --quiet                       do not report progress
-r, --refresh                     refresh after  addition of script or module
-R, --rpm-build                   enable or disable RPM spec file
    --no-rpm-install-from-cpan    disable installation of Perl modules in \%post section
-s, --source-dir       directory  source directory for files in manifest or when creating manifest
                                  (default: pwd)
-u, --unit-tests                  create unit test stubs (default: true)
-v, --version                     report script version

These options default to true, use --no-{option} to disable

--bash
--html
--rpm-build
--unit-tests

This utility is part of the `autoconf-template-perl` toolchain. It will
create an autoconfiscated Perl application based on the description
contained in a manifest file.

See `perldoc Autoconf::Template` for more info.

$COPYRIGHT
END_OF_HELP
}

########################################################################
sub load_autoconf_templaterc {
########################################################################
  my ($options) = @_;

  my $rc_file = $options->{conf};

  if ( !$rc_file ) {
    my @paths = ( $ENV{HOME}, $PROJECT_DIR );

    eval {
      find(
        { no_chdir => $TRUE,
          wanted   => sub {
            return if !/[.]autoconf-template-perlrc/xsm;
            $rc_file = $File::Find::name;

            die 'found';
          }
        },
        @paths
      );
    };

  }

  croak "could not find your configuration file ($rc_file)\n"
    if $rc_file && !-e $rc_file;

  $options->{conf} = $rc_file;

  if ( -e "$rc_file" ) {
    $options->{autoconf_template_perlrc}
      = Config::IniFiles->new( -file => $rc_file );
  }

  return;
}

########################################################################
sub get_stubs {
########################################################################
  my ($options) = @_;

  my $config = $options->{autoconf_template_perlrc};

  my @stubs;

  foreach ( $config->Parameters('stubs') ) {
    push @stubs,
      {
      type => sprintf( '%5s', ".$_" ),
      path => $config->val( 'stubs', $_ )
      };
  }

  return @stubs;
}

########################################################################
sub list_stubs {
########################################################################
  my ($options) = @_;

  my @stubs = get_stubs($options);

  my $dist_dir = dist_dir('Autoconf-Template');

  print easy_table(
    data          => \@stubs,
    table_options => { headingText => 'Artifact Templates' },
    rows          => [ 'Type', 'type', 'Path', 'path' ],
  );

  return \@stubs;
}

########################################################################
sub check_for_autotools {
########################################################################
  for (qw(autoconf automake make)) {
    `$_ --version >/dev/null 2>&1`;
    croak "you're missing $_ or it's not your path\n"
      if $CHILD_ERROR ne '0';
  }

  return;
}

########################################################################
sub find_perl_modules {
########################################################################
  my ($options) = @_;

  # find all the Perl modules under src/main/perl/lib and create a
  # dependency tree. This will feed the perl-modules.inc.tt template
  # that creates build rules based on dependencies within the project
  # itself.
  #
  # If we want to syntactically check all Perl modules we need to
  # build modules that are dependencies of other modules first within
  # the build tree.
  #
  # 1. Find all of the Perl modules in the build tree and then call
  # get_dependencies() which uses Module::ScanDeps::Static to find
  # dependencies for each module that are satisfied locally.
  #
  # 2. Create dependency tree (more of a listing) for each module
  #
  # 3. Create an array of module names that will be used in the Makefile.am
  #
  # 4. perl-modules.inc is the rendered with all the other templates

  my $perl_lib_root = $options->{root} . '/src/main/perl/lib';
  my $dirs          = get_subdirs($perl_lib_root);

  my $dependencies = get_dependencies($options);

  $options->{modules}
    = create_dependency_tree( $dirs, $dependencies, $perl_lib_root );

  foreach my $file ( keys %{$dependencies} ) {
    strip_in( $dependencies->{$file} );
    $dependencies->{ strip_in($file) } = $dependencies->{$file};
  }

  $options->{dependencies} = $dependencies;

  DEBUG Dumper(
    [ 'dependencies', $dependencies, 'modules', $options->{modules} ] );

  $options->{module_names} = [];

  for ( @{ $options->{modules} } ) {
    push @{ $options->{module_names} }, sprintf q{$} . q{(%sMODULES)},
      $_->{name_uc};
  }

  return $options;
}

########################################################################
sub find_local_dependencies {
########################################################################
  my ( $modules, $path ) = @_;

  my $output = {};

  for my $file ( @{$modules} ) {
    my $this = $file;
    $this =~ s/$path\///xsm;

    $output->{$this} = [];

    if ( $file !~ /[.]in$/xsm ) {
      $file = "$file.in";
    }

    my $scanner = Module::ScanDeps::Static->new(
      { core => 0,
        path => "$file",
      }
    );

    $scanner->parse;

    my @dependencies = $scanner->get_dependencies();

    DEBUG Dumper( [ 'dependencies', \@dependencies, 'modules', $modules ] );

    for my $d (@dependencies) {
      my $name = module_to_path( $d->{name} );

      TRACE 'looking for ' . $name;

      next if none {/$name/xsm} @{$modules};

      TRACE Dumper( [ $this, $name ] );

      push @{ $output->{$this} }, "$name.in";
    }

  }

  return { modules => $output };
}

########################################################################
sub get_subdirs {
########################################################################
  my ( $path, $dirs ) = @_;

  opendir my $fh, "$path"
    or croak "could not open directory: $OS_ERROR";

  while ( my $file = readdir $fh ) {

    next if $file =~ /^[t.][.]?$/xsm;

    if ( -d "$path/$file" ) {
      $dirs->{"$path/$file"} = [];
      $dirs = get_subdirs( "$path/$file", $dirs );
    }
    else {
      if ( $file =~ /[.]pm[.]in$/xsm ) {
        push @{ $dirs->{$path} }, $file;
      }
    }
  }

  closedir $fh;

  return $dirs;
}

########################################################################
sub create_source_tree {
########################################################################
  my ($options) = @_;

  my $root = $options->{root};

  my $main_prefix = sprintf '%s/src/main', $root;

  croak "directory $main_prefix exists - use -f to force\n"
    if -d $main_prefix && !$options->{force} && !$options->{refresh};

  for (qw(config resources)) {
    make_path( sprintf '%s/%s', $root, $_ );
  }

  my $manifest = $options->{manifest};

  my @main_dirs = qw(perl);

  DEBUG Dumper( [ 'manifest', $manifest ] );

  DEBUG Dumper( [ 'build tree options', [ @{$options}{qw(bash html)} ] ] );

  for (qw(bash html)) {
    if ( $options->{ $_ . '_build_mode' } ) {
      push @main_dirs, $_;
    }
  }

  foreach (@main_dirs) {
    make_path("$main_prefix/$_");
  }

  my @perl_dirs = qw(lib bin);
  push @perl_dirs, $options->{html_build_mode} ? 'cgi-bin' : ();

  foreach (@perl_dirs) {
    make_path("$main_prefix/perl/$_");
  }

  my @bash_dirs;

  if ( $options->{bash_build_mode} ) {
    @bash_dirs = 'bin';

    foreach (@bash_dirs) {
      make_path("$main_prefix/bash/$_");
    }
  }

  DEBUG Dumper( [ 'dirs', \@main_dirs, \@bash_dirs, \@perl_dirs ] );

  my (@makefiles) = (
    "$root/src/Makefile.am"           => ['main'],
    "$root/src/main/Makefile.am"      => \@main_dirs,
    "$root/src/main/bash/Makefile.am" => \@bash_dirs,
    "$root/src/main/perl/Makefile.am" => \@perl_dirs,
  );

  foreach my $p ( pairs @makefiles ) {
    my ( $makefile, $subdirs ) = @{$p};
    next if !@{$subdirs};

    render_tt_template(
      { template   => 'Makefile.tt',
        parameters => { dir_list => $subdirs },
        outfile    => $makefile
      }
    );
  }

  return;
}

########################################################################
sub _copy_files {
########################################################################
  my (%args) = @_;

  my ( $prefix, $file_list, $add_in, $options )
    = @args{qw(prefix files add_in options)};

  for my $file ( @{$file_list} ) {
    my $dest = basename $file;

    DEBUG Dumper( [ 'source ', $file, 'basename ', $dest ] );

    # .pm files, we may have a directory hierarchy that we want to
    # reflect in the build tree. IOW, for Foo/Bar/Baz.pm it needs
    # to be installed in:
    #
    #   src/main/perl/lib/Foo/Bar
    #
    # ...not src/main/perl/lib
    #
    # so use the package name to reflect the directory hierarchy
    #
    if ( $file =~ /[.]pm/xsm ) {
      $dest = find_module_filename($file);
    }

    if ( $add_in && $file !~ /[.]in$/xsm ) {
      $dest = "$dest.in";
    }

    DEBUG Dumper( [ 'creating/copying path', "$prefix/$dest" ] );

    create_path("$prefix/$dest");

    if ( -e $file ) {
      copy( $file, "$prefix/$dest" );
    }
    else {
      # see if we have a stub for this type...

      my ( $name, $path, $ext ) = fileparse( $file, qr/[.][^.]+$/xsm );

      DEBUG Dumper( [ 'creating file ', $file, $name, $path, $ext ] );

      my $stub_name = "$TEMPLATES_DIR/stub$ext.tt";

      if ( -e $stub_name ) {
        my %parameters = %{$options};
        $parameters{template_name} = $stub_name;

        DEBUG Dumper( [ 'found a template ', $stub_name ] );

        if ( $ext eq '.pm' ) {
          my $module_name = path_to_module($file);
          $parameters{module_name} = $module_name;
        }

        render_tt_template(
          { template   => $stub_name,
            parameters => \%parameters,
            outfile    => "$prefix/$dest",
          }
        );
      }
      else {
        DEBUG 'no template found for: ' . $file;

        # create empty missing file
        open my $fh, '>', "$prefix/$dest"
          or croak "could not create missing $file in $prefix/$dest\n";

        close $fh;
      }
    }
  }

  return;
}

########################################################################
sub copy_files {
########################################################################
  my ($options) = @_;

  my $manifest = $options->{manifest};
  my $root     = $options->{root};

  _copy_files(
    prefix  => $root . '/resources',
    files   => $manifest->{resources},
    add_in  => $FALSE,
    options => $options,
  );

  _copy_files(
    prefix  => $root . '/config',
    files   => $manifest->{config},
    add_in  => $TRUE,
    options => $options,
  );

  my $main_prefix = sprintf '%s/src/main', $root;

  for (qw(lib cgi-bin bin)) {
    _copy_files(
      prefix  => "$main_prefix/perl/$_",
      files   => $manifest->{perl}->{$_},
      add_in  => $TRUE,
      options => $options,
    );
  }

  _copy_files(
    prefix  => "$main_prefix/bash/bin",
    files   => $manifest->{bash}->{bin},
    add_in  => $TRUE,
    options => $options,
  );

  # create the directory structure and 'Makefile.am' even
  # if we don't have files if html is include it the manifest
  if ( $manifest->{html} ) {
    for (qw(htdocs javascript css image)) {
      _copy_files(
        prefix  => "$main_prefix/html/$_",
        files   => $manifest->{html}->{$_},
        add_in  => $FALSE,
        options => $options,
      );
    }
  }

  return;
}

########################################################################
sub make_absolute {
########################################################################
  my ( $srcdir, $file ) = @_;

  return $file if $file =~ /\//xsm;

  return "$srcdir/$file";
}

########################################################################
sub check_manifest {
########################################################################
  my ($options) = @_;

  my $manifest = eval { LoadFile( $options->{manifest} ); };

  # manifest overrides other parameters
  foreach (qw(project email description author)) {
    $options->{$_} = $manifest->{$_};
  }

  if ( !$manifest || $EVAL_ERROR ) {
    croak "could not load manifest file: $EVAL_ERROR\n";
  }

  my $srcdir = $options->{'source-dir'};

  # check manifest
  for (qw(config resources)) {
    next if !$manifest->{$_};

    for my $file ( @{ $manifest->{$_} } ) {
      $file = expand_filename($file);

      croak "$file does not exist"
        if !-e $file && !$options->{'create-missing'};

      $file = make_absolute( $srcdir, $file );
    }
  }

  for my $dir (qw(bin cgi-bin lib)) {
    next if !$manifest->{perl}->{$dir};

    for my $file ( @{ $manifest->{perl}->{$dir} } ) {
      $file = expand_filename($file);

      croak "$file does not exist"
        if !-e $file && !$options->{'create-missing'};

      # only make files that exist absolute, otherwise we won't create
      # package name correctly
      next if $dir eq 'lib' && !-e $file;

      $file = make_absolute( $srcdir, $file );
    }
  }

  if ( $manifest->{config} ) {
    foreach my $file ( @{ $manifest->{config} } ) {
      INFO 'config: ' . $file;
      $file = expand_filename($file);

      croak sprintf "config files should have extensions of %s\n",
        join $COMMA, values %CONFIG_FILE_EXTENSIONS
        if none { $file =~ /[.]$_$/xsm } values %CONFIG_FILE_EXTENSIONS;

      $file = make_absolute( $srcdir, $file );
    }
  }

  return $manifest;
}

########################################################################
sub get_dependencies {
########################################################################
  my ($options) = @_;

  my $perl_lib_root = $options->{root} . '/src/main/perl/lib';

  my @perl_modules;

  croak q{this doesn't look much like a project directory}
    if !-d $perl_lib_root;

  @perl_modules = find_files( $perl_lib_root, 'pm', $FALSE );

  my $dirs = get_subdirs($perl_lib_root);

  my $all_dependencies = eval {
    return find_local_dependencies( [@perl_modules], $perl_lib_root );
  };

  croak "error gathering dependencies: $EVAL_ERROR"
    if !$all_dependencies || $EVAL_ERROR;

  DEBUG Dumper( [ 'dependencies', $all_dependencies ] );

  return $all_dependencies->{modules};
}

########################################################################
sub makefile_am_list {
########################################################################
  my ( $file_list, $dir ) = @_;

  return $EMPTY if !ref $file_list || !@{$file_list};

  my @files = @{$file_list};

  if ($dir) {
    @files = map {"$dir/$_"} @files;
  }

  my $list = join " \\\n    ", @files;

  return "\\\n    " . $list;
}

########################################################################
sub find_resources {
########################################################################
  my ($root) = @_;

  my @resources;

  find(
    sub {
      return if /^Makefile/xsm || -d $File::Find::name;

      push @resources, basename $File::Find::name;
    },
    "$root/resources"
  );

  return \@resources;
}

########################################################################
sub init_parameters {
########################################################################
  my ($options) = @_;

  my @now = localtime;
  $now[5] += 1900;
  $now[4] += 1;

  my $root = $options->{root};

  my %timestamp = timestamp();

  $options->{date}      = $timestamp{date};
  $options->{timestamp} = $timestamp{timestamp};

  # Fri Feb 10 14:16:12 2023
  $options->{version}   = '@PACKAGE_VERSION@';   ## no critic (RequireInterpolation)
  $options->{generator} = basename $PROGRAM_NAME;

  # convenience routines for TT
  # creates a list that looks like this:
  # FOO = \
  #     ITEM \
  #     ITEM \
  #     ITEM
  $options->{makefile_am_list} = \&makefile_am_list;

  if ( $options->{refresh} ) {
    # main() prepped 'destdir', 'project' for refresh option from
    # abs_top_srcdir in Makefile, so we should be certain that root
    # for refresh is correct...

    $options->{resources} = find_resources($root);

    # refresh the list of files for 'built' assets look for .in files
    # in each directory, presumably someone dropped a new .in file in
    # one of these and wants to refresh the Makefile.am

    my %html_files = (
      html       => [ 'htdocs',     ['html'] ],
      javascript => [ 'javascript', ['js'] ],
      css        => [ 'css',        ['css'] ],
      image      => [ 'image',      [qw(png gif jpeg jpg)] ],
    );

    foreach ( keys %html_files ) {
      my $file_list = $_ . '_files';

      $options->{$file_list} = [];

      my ( $subdir, $ext_list ) = @{ $html_files{$_} };

      foreach my $file_type ( @{$ext_list} ) {

        my @files = find_files_of_type(
          path => "$root/src/main/html/$subdir",
          type => $file_type,
        );

        push @{ $options->{$file_list} }, map { basename $_ } @files;
      }
    }

    $options->{bash_scripts}
      = [ find_files( "$root/src/main/bash/bin", 'sh', $TRUE ) ];

    $options->{perl_scripts}
      = [ find_files( "$root/src/main/perl/bin", 'pl', $TRUE ) ];

    $options->{cgi_scripts}
      = [ find_files( "$root/src/main/perl/cgi-bin", 'pl', $TRUE ) ];

    $options->{perl_modules}
      = [ find_files( "$root/src/main/perl/lib", 'pm', $TRUE ) ];

    TRACE Dumper( [ perl_modules => $options->{perl_modules} ] );

    $options->{perl_modules}
      = [ map { find_module_filename( $_ . '.in' ) }
        @{ $options->{perl_modules} } ];

    DEBUG Dumper(
      [ 'refreshing',
        bash_scripts => $options->{bash_scripts},
        perl_scripts => $options->{perl_scripts},
        perl_modules => $options->{perl_modules},
        cgi_scripts  => $options->{cgi_scripts},
        resources    => $options->{resources},
      ]
    );

    for my $script_type (qw(bash perl cgi)) {
      $options->{ $script_type . '_scripts' }
        = [ map { ( basename $_) . '.in' }
          @{ $options->{ $script_type . '_scripts' } } ];
    }

    DEBUG Dumper(
      [ 'refreshed',
        bash_scripts => $options->{bash_scripts},
        perl_scripts => $options->{perl_scripts},
        perl_modules => $options->{perl_modules},
        cgi_scripts  => $options->{cgi_scripts},
        resources    => $options->{resources},
      ]
    );

    # find all config files...we may have a new file here too
    my @config_files;

    foreach ( values %CONFIG_FILE_EXTENSIONS ) {
      push @config_files, find_files( "$root/config", $_, $TRUE );
    }

    $options->{config} = [@config_files];

    init_config_sections( $options, \@config_files );

    DEBUG Dumper( [ 'config sections', \@config_files, $options ] );
  }
  else {
    my $manifest = $options->{manifest};

    $options->{author}  //= $manifest->{author};
    $options->{email}   //= $manifest->{email};
    $options->{project} //= $manifest->{project};

    $options->{description} = $manifest->{description};

    my @build_file_lists = (
      bash_scripts => $manifest->{bash}->{bin},
      perl_scripts => $manifest->{perl}->{bin},
      cgi_scripts  => $manifest->{perl}->{'cgi-bin'},
    );

    # config files should technically be above list, but we add .in to
    # those files in init_config_sections
    my @file_lists = (
      html_files       => $manifest->{html}->{htdocs},
      javascript_files => $manifest->{html}->{javascript},
      css_files        => $manifest->{html}->{css},
      image_files      => $manifest->{html}->{image},
      resources        => $manifest->{resources},
      config           => $manifest->{config},
    );

    create_target_file_list( $options, \@build_file_lists, '.in' );

    create_target_file_list( $options, \@file_lists );

    $options->{perl_modules}
      = [ map { find_module_filename($_) } @{ $manifest->{perl}->{lib} } ];

    # create arrays for each config files type that will be used in
    # the config/Makefile.am template ('ini_files', 'cfg_files', etc)
    init_config_sections( $options, $options->{manifest}->{config} );
  }

  return $options;
}

# remove path info and possibly add '.in' for files to be built
########################################################################
sub create_target_file_list {
########################################################################
  my ( $options, $file_list, $ext ) = @_;

  $ext //= $EMPTY;

  # create arrays of just the file names from the source files
  for my $p ( pairs @{$file_list} ) {
    my ( $var, $list ) = @{$p};

    $list ||= [];

    $options->{$var} = [ map { basename($_) . $ext } @{$list} ];
  }

  return $options;
}

########################################################################
sub init_config_sections {
########################################################################
  my ( $options, $configs ) = @_;

  return $options
    if !ref $configs || !@{$configs};

  # find files of type .ini, .cfg, .json, .yaml and create a
  # parameter in the options hash for each type to be used by the
  # 'config/Makefile.am.tt' template
  #
  # [% ini_files %], e.g.
  #
  foreach my $p ( pairs %CONFIG_FILE_EXTENSIONS ) {
    my ( $type, $ext ) = @{$p};

    my @config_files = grep {/[.]$ext$/xsm} @{$configs};

    foreach (@config_files) {
      s/$/.in/xsm;
    }

    $options->{$type} = [ map { basename $_ } @config_files ];
  }

  return $options;
}

########################################################################
sub render_templates {
########################################################################
  my ($parameters) = @_;

  my $file_list = $parameters->{file_list};
  my $templates = $file_list->{templates};

  my $exclude_templates = $parameters->{exclude_templates};

  for my $template ( keys %{$templates} ) {
    TRACE sprintf 'checking to see if we need to refresh: %s', $template;
    next if any { $template eq $_ } @{$exclude_templates};

    if ( $parameters->{refresh} ) {
      next if none { $template eq $_ } @{ $file_list->{refresh} };
    }

    TRACE sprintf 'refreshing: %s', $template;
    my ( $mode, $out, $cleanup );

    if ( ref $templates->{$template} ) {
      ( $mode, $out, $cleanup ) = @{ $templates->{$template} };
    }
    else {
      ( $mode, $out ) = ( undef, $templates->{$template} );
    }

    $out = sprintf '%s/%s', $parameters->{root}, $out;

    # resolve any variables in file names (@project@.spec.in), e.g.
    $out = do_subst( $out, $parameters );

    render_tt_template(
      { template   => $template,
        parameters => $parameters,
        outfile    => $out,
        cleanup    => $cleanup,
      }
    );

    if ( defined $mode && $mode ) {
      TRACE sprintf 'setting permissions of  %s to %s', $out, $mode // $EMPTY;
      chmod oct($mode), $out;
    }
  }

  return;
}

########################################################################
sub create_requirement_files {
########################################################################
  my ($options) = @_;

  my $root = $options->{root};

  my $m4_macro = sprintf '%s/autotools/ax_requirements_check.m4', $root;

  my $requirements_text = sprintf '%s/requires.txt',  $root;
  my $requirements_json = sprintf '%s/requires.json', $root;

  my %outfiles = (
    m4   => $m4_macro,
    text => $requirements_text,
    json => $requirements_json,
  );

  ## no critic (RequireInterpolationOfMetachars)
  my @ax_requirements_check = '@bindir@/autoconf-ax-requirements-check';

  # set rootdir option
  push @ax_requirements_check, '-r', $root;

  # pass along log-level...and quiet flag
  push @ax_requirements_check, '-l', $options->{'log-level'};

  push @ax_requirements_check, $options->{quiet} ? '-Q' : ();

  # create the JSON file first
  system @ax_requirements_check, '-o', $outfiles{'json'}, '-f', 'json';

  # create requirements file for each format using JSON file as input
  for my $format (qw( text m4 )) {
    system @ax_requirements_check, '-o', $outfiles{$format}, '-f', $format,
      '-i', $outfiles{'json'};
  }

  return;
}

########################################################################
sub create_changelog {
########################################################################
  my ($options) = @_;

  my @all_files;

  my $root = $options->{root};

  find(
    sub {
      return if -d $_;
      push @all_files, $File::Find::name;
    },
    $root
  );

  for (@all_files) {
    s/^\/?$root\///xsm;
  }

  @all_files = sort { lc $a cmp lc $b } @all_files;

  my $parameters = { %{$options}, files => \@all_files };

  render_tt_template(
    { template   => 'ChangeLog.tt',
      parameters => $parameters,
      outfile    => sprintf( '%s/%s', $root, 'ChangeLog' ),
    }
  );

  return;
}

########################################################################
sub do_subst {
########################################################################
  my ( $arg, $parameters ) = @_;

  TRACE "do_subst($arg)";

  while ( $arg =~ /\@([^\@]+)\@/xsm ) {
    TRACE "found substitution var $1";

    die "$1 is not defined in your parameter list\n"
      if !exists $parameters->{$1};

    my $val = $parameters->{$1};
    $arg =~ s/\@$1\@/$val/xsmg;

    TRACE "arg now [$arg]";
  }

  return $arg;
}

########################################################################
sub copy_list {
########################################################################
  my ($options) = @_;

  my $root = $options->{root};

  my $file_list = $options->{file_list}->{files};

  foreach my $file ( keys %{$file_list} ) {

    my ( $mode, $out )
      = ref $file_list->{$file}
      ? @{ $file_list->{$file} }
      : ( undef, $file_list->{$file} );

    $out ||= $file;
    $out = do_subst( $out, $options );

    my $dest_path;

    if ( $out =~ /\/$/xsm ) {
      $dest_path = sprintf '%s/%s/%s', $root, $out, $file;
    }
    else {
      $dest_path = sprintf '%s/%s', $root, $out;
    }

    create_path($dest_path);

    TRACE sprintf 'copying %s to %s', "$PROJECT_DIR/$file", $dest_path;

    croak "missing $file - perhaps you forgot to add it to Makefile.am?\n"
      if !-e "$PROJECT_DIR/$file";

    copy( "$PROJECT_DIR/$file", $dest_path );

    if ( defined $mode ) {
      TRACE sprintf 'chmod %s, %s', $mode, $dest_path;
      chmod oct($mode), $dest_path;
    }
  }

  return;
}

########################################################################
sub create_dependency_tree {
########################################################################
  my ( $dirs, $all_dependencies, $root ) = @_;

  my @modules;

  foreach my $dir ( sort keys %{$dirs} ) {
    my %module;

    my $path = $dir;
    $path =~ s{$root/?}{}xsm;

    $module{path} = $path;

    my $list = $dirs->{$dir};

    $module{list} = [];

    foreach my $file ( @{$list} ) {
      push @{ $module{list} }, $path ? "$path/$file" : $file;
    }

    my $module_name = $path;
    $module_name =~ s/\///xsm;
    $module{name_uc} = uc $module_name || 'PERL';
    $module{name_lc} = lc $module_name;

    $module{files}        = $list;
    $module{dependencies} = {};

    foreach my $file ( @{$list} ) {
      my $dependencies = [];

      DEBUG 'looking for ' . $path . $SLASH . $file;

      my $dep_file = $path . $SLASH . $file;
      $dep_file = strip_in($dep_file);
      $dep_file =~ s/^\///xsm;

      my @local_dependencies
        = @{ $all_dependencies->{$dep_file} || [] };

      next if !@local_dependencies;

      for my $dependency (@local_dependencies) {
        $dependency = strip_in($dependency);
        push @{$dependencies}, $dependency;
      }

      $module{dependencies}->{$file} = $dependencies;
    }

    push @modules, \%module;
  }

  return \@modules;
}

1;

__END__
