#!/usr/bin/env perl
# -*- mode: perl; -*-

# autoconfisication of Perl applications

use strict;
use warnings;

use Autoconf::Constants qw(:all);
use Autoconf::Utils qw(:all);
use Carp qw(croak);
use Carp::Always;
use Cwd;
use Data::Dumper;
use Date::Format qw(time2str);
use English qw(-no_match_vars);
use File::Basename qw(basename fileparse dirname);
use File::Copy;
use File::Find;
use File::Path qw(make_path);
use Getopt::Long;
use JSON qw(decode_json);
use List::Util qw(any none pairs);
use Log::Log4perl qw(:easy get_logger);
use Module::ScanDeps::Static;
use YAML qw(LoadFile DumpFile);

our $VERSION = '@PACKAGE_VERSION@'; ## no critic (RequireInterpolation)

caller or __PACKAGE__->main();

########################################################################
sub main {
########################################################################
  init_logger();

  my $file_list = slurp_file( $FILE_LIST, type => 'json' );

  my %options = ( file_list => $file_list );

  GetOptions(
    \%options,   'scripts', 'project=s', 'author=s',
    'email=s',   'help',    'version',   'manifest=s',
    'destdir=s', 'force',   'refresh',   'create-missing',
  );

  return help()
    if $options{help};

  return version($VERSION)
    if $options{version};

  croak 'no destination dir, '
    . "use --destdir to specify the locaiton for the build tree\n"
    if !$options{destdir} && !$options{refresh};

  my $meta_data;

  # find manifest if not doing a refresh
  if ( !$options{refresh} ) {
    $options{manifest} //= $MANIFEST_FILE; # check cwd for manifest.yaml

    croak "no manifest, use --manifest to specify a YAML manifest\n"
      if !-e $options{manifest};

    $options{manifest} = check_manifest( \%options );
  }
  else {
    @options{qw(project destdir)} = find_root_dir();

    my $meta_data_file = sprintf '%s/%s/%s', @options{qw( destdir project)},
      'project.yaml';

    $meta_data = eval { LoadFile($meta_data_file) };
  }

  $meta_data //= {};

  init_parameters( \%options );

  DEBUG Dumper( [ 'options', \%options ] );

  if ( !$options{refresh} ) {
    create_build_tree( \%options );

    # copy files from manifest to target directories
    copy_files( \%options );
  }

  find_perl_modules( \%options );

  if ( !$options{refresh} ) {

    create_unit_tests( \%options, $options{dependencies} );

    # copy extra files that do not need to be rendered, but are required
    # for the project's autoconfiscation to the project directory (see
    # resources/file_list.json)

    copy_list( \%options );
  }

  DEBUG Dumper( [ 'options', \%options ] );

  # render the templates: parameters needed are set in the %options
  # hash. templates are listed in 'file_list.json' and
  # 'tempaltes//Makfile.am'.
  render_templates( \%options );

  # create an m4 macro which is called out in 'configure.ac' that
  # checks to see if the required Perl modules are present in the
  # target environment.

  create_ax_requirements_check( \%options );

  # create ChangeLog AFTER all files have been created in new project
  # directory

  if ( !$options{refresh} ) {
    $meta_data = {
      project       => $options{project},
      email         => $options{email},
      author        => $options{author},
      creation_date => scalar localtime,
    };

    DumpFile( "$options{destdir}/project.yaml", $meta_data );

    # create autotools/ax-extra-opts.m4
    system 'autoconf-ax-extra-opts', '--root', $options{destdir};

    create_changelog( \%options );
  }

  return;
}

########################################################################
sub help {
########################################################################
  my $name = basename $PROGRAM_NAME;

  return print <<"END_OF_HELP";
usage: $name options

Options
-------
-h, --help            help
-a, --author          author's name
-c, --create-missing  create any files in manifest that do not exist
-d, --destdir         root for project directory
-e, --email           author's email
-f, --force           force overwrite of project directory
-m, --manifest        name of the YAML manifest file
-p, --project         project name
-r, --refresh         refresh after  addition of script or module
-v, --version         report script version

This utility is part of the `autoconf-template-perl` toolchain. It will
create an autoconfiscated Perl application based on the description
contained in a manifest file.

See `perldoc Autoconf::Template` for more of the gory details.

$COPYRIGHT
END_OF_HELP
}

########################################################################
sub find_perl_modules {
########################################################################
  my ($options) = @_;

  # find all the Perl modules under src/main/perl/lib and create a
  # dependency tree. This will feed the perl-modules.inc.tt template
  # that creates build rules based on dependencies within the project
  # itself.
  #
  # If we want to syntactically check all Perl modules we need to
  # build modules that are dependencies of other modules first within
  # the build tree.
  #
  # 1. Find all of the Perl modules in the build tree and then call
  # get_dependencies() which uses Module::ScanDeps::Static to find
  # dependencies for each module that are satisfied locally.
  #
  # 2. Create dependency tree (more of a listing) for each module
  #
  # 3. Create an array of module names that will be used in the Makefile.am
  #
  # 4. perl-modules.inc is the rendered with all the other templates

  my $root = $options->{destdir} . '/src/main/perl/lib';
  my $dirs = get_subdirs($root);

  my $dependencies = get_dependencies($options);

  $options->{modules} = create_dependency_tree( $dirs, $dependencies, $root );

  foreach my $file ( keys %{$dependencies} ) {
    strip_in( $dependencies->{$file} );
    $dependencies->{ strip_in($file) } = $dependencies->{$file};
  }

  $options->{dependencies} = $dependencies;

  DEBUG Dumper(
    [ 'dependencies', $dependencies, 'modules', $options->{modules} ] );

  $options->{module_names} = [];

  for ( @{ $options->{modules} } ) {
    push @{ $options->{module_names} }, sprintf q{$} . q{(%sMODULES)},
      $_->{name_uc};
  }

  return $options;
}

########################################################################
sub find_local_dependencies {
########################################################################
  my ( $modules, $path ) = @_;

  my $output = {};

  for my $file ( @{$modules} ) {
    my $this = $file;
    $this =~ s/$path\///xsm;

    $output->{$this} = [];

    if ( $file !~ /[.]in$/xsm ) {
      $file = "$file.in";
    }

    my $scanner = Module::ScanDeps::Static->new(
      { core => 0,
        path => "$file",
      }
    );

    $scanner->parse;

    my @dependencies = $scanner->get_dependencies();

    DEBUG Dumper( [ 'dependencies', \@dependencies, 'modules', $modules ] );

    for my $d (@dependencies) {
      my $name = module_to_path( $d->{name} );

      TRACE 'looking for ' . $name;

      next if none {/$name/xsm} @{$modules};

      TRACE Dumper( [ $this, $name ] );

      push @{ $output->{$this} }, "$name.in";
    }

  }

  return { modules => $output };
}

########################################################################
sub get_subdirs {
########################################################################
  my ( $path, $dirs ) = @_;

  opendir my $fh, "$path"
    or croak "could not open directory: $OS_ERROR";

  while ( my $file = readdir $fh ) {

    next if $file =~ /^[t.][.]?$/xsm;

    if ( -d "$path/$file" ) {
      $dirs->{"$path/$file"} = [];
      $dirs = get_subdirs( "$path/$file", $dirs );
    }
    else {
      if ( $file =~ /[.]pm[.]in$/xsm ) {
        push @{ $dirs->{$path} }, $file;
      }
    }
  }

  closedir $fh;

  return $dirs;
}

########################################################################
sub create_build_tree {
########################################################################
  my ($options) = @_;

  my $main_prefix = sprintf '%s/src/main', $options->{destdir};

  croak "directory $main_prefix exists - use -f to force\n"
    if -d $main_prefix && !$options->{force};

  for (qw(config resources)) {
    make_path("$options->{destdir}/$_");
  }

  my $manifest = $options->{manifest};

  my @main_dirs = qw(bash perl html);

  foreach (@main_dirs) {
    make_path("$main_prefix/$_");
  }

  my @perl_dirs = qw(lib bin cgi-bin);

  foreach (@perl_dirs) {
    make_path("$main_prefix/perl/$_");
  }

  my @bash_dirs = qw(bin);

  foreach (@bash_dirs) {
    make_path("$main_prefix/bash/$_");
  }

  my (@makefiles) = (
    "$options->{destdir}/src/Makefile.am"           => ['main'],
    "$options->{destdir}/src/main/Makefile.am"      => \@main_dirs,
    "$options->{destdir}/src/main/bash/Makefile.am" => \@bash_dirs,
    "$options->{destdir}/src/main/perl/Makefile.am" => \@perl_dirs,
  );

  foreach my $p ( pairs @makefiles ) {
    my ( $makefile, $subdirs ) = @{$p};
    next if !@{$subdirs};

    render_tt_template( 'Makefile.tt', { dir_list => $subdirs }, $makefile );
  }

  return;
}

########################################################################
sub _copy_files {
########################################################################
  my (%args) = @_;

  my ( $prefix, $file_list, $add_in, $options )
    = @args{qw(prefix files add_in options)};

  for my $file ( @{$file_list} ) {
    my $dest = basename $file;

    DEBUG Dumper( [ 'source ', $file, 'basename ', $dest ] );

    # .pm files, we may have a directory hierarchy that we want to
    # reflect in the build tree. IOW, for Foo/Bar/Baz.pm it needs
    # to be installed in:
    #
    #   src/main/perl/lib/Foo/Bar
    #
    # ...not src/main/perl/lib
    #
    # so use the package name to reflect the directory hierarchy
    #
    if ( $file =~ /[.]pm/xsm ) {
      $dest = find_module_filename($file);
    }

    if ( $add_in && $file !~ /[.]in$/xsm ) {
      $dest = "$dest.in";
    }

    DEBUG Dumper( [ 'creating/copying path', "$prefix/$dest" ] );

    create_path("$prefix/$dest");

    if ( -e $file ) {
      copy( $file, "$prefix/$dest" );
    }
    else {
      # see if we have a stub for this type...
      my ( $name, $path, $ext ) = fileparse( $file, qr/[.][^.]+$/xsm );

      DEBUG Dumper( [ 'creating file ', $file, $name, $path, $ext ] );

      if ( -e "$PROJECT_DIR/templates/stub$ext.tt" ) {
        my %parameters = %{$options};
        $parameters{template_name} = "$PROJECT_DIR/templates/stub$ext.tt";

        DEBUG Dumper( [ 'found a template ', $parameters{template_name} ] );

        if ( $ext eq '.pm' ) {
          my $module_name = path_to_module($file);
          $parameters{module_name} = $module_name;
        }

        render_tt_template( $parameters{template_name},
          \%parameters, "$prefix/$dest" );
      }
      else {
        # create empty missing file
        open my $fh, '>', "$prefix/$dest"
          or croak "could not create missing $file in $prefix/$dest\n";

        close $fh;
      }
    }
  }

  return;
}

########################################################################
sub copy_files {
########################################################################
  my ($options) = @_;

  my $manifest = $options->{manifest};

  _copy_files(
    prefix  => $options->{destdir} . '/resources',
    files   => $manifest->{resources},
    add_in  => $FALSE,
    options => $options,
  );

  _copy_files(
    prefix  => $options->{destdir} . '/config',
    files   => $manifest->{config},
    add_in  => $TRUE,
    options => $options,
  );

  my $main_prefix = sprintf '%s/src/main', $options->{destdir};

  for (qw(lib cgi-bin bin)) {
    _copy_files(
      prefix  => "$main_prefix/perl/$_",
      files   => $manifest->{perl}->{$_},
      add_in  => $TRUE,
      options => $options,
    );
  }

  _copy_files(
    prefix  => "$main_prefix/bash/bin",
    files   => $manifest->{bash}->{bin},
    add_in  => $TRUE,
    options => $options,
  );

  # create the directory structure and 'Makefile.am' even
  # if we don't have files if html is include it the manifest
  if ( $manifest->{html} ) {
    for (qw(htdocs javascript css images)) {
      _copy_files(
        prefix  => "$main_prefix/html/$_",
        files   => $manifest->{html}->{$_},
        add_in  => $FALSE,
        options => $options,
      );
    }
  }

  return;
}

########################################################################
sub check_manifest {
########################################################################
  my ($options) = @_;

  my $manifest = eval { LoadFile( $options->{manifest} ); };

  if ( !$manifest || $EVAL_ERROR ) {
    croak "could not load manifest file: $EVAL_ERROR\n";
  }

  # check manifest
  for (qw(config resources)) {
    next if !$manifest->{$_};

    for my $file ( @{ $manifest->{$_} } ) {
      $file = expand_filename($file);

      croak "$file does not exist"
        if !-e $file && !$options->{'create-missing'};

    }
  }

  for (qw(bin cgi-bin lib)) {
    next if !$manifest->{perl}->{$_};

    for my $file ( @{ $manifest->{perl}->{$_} } ) {
      $file = expand_filename($file);

      croak "$file does not exist"
        if !-e $file && !$options->{'create-missing'};
    }
  }

  if ( $manifest->{config} ) {
    foreach my $file ( @{ $manifest->{config} } ) {
      $file = expand_filename($file);

      croak sprintf "config files should have extensions of %s\n",
        join $COMMA, values %CONFIG_FILE_EXTENSIONS
        if none { $file =~ /[.]$_$/xsm } values %CONFIG_FILE_EXTENSIONS;
    }
  }

  return $manifest;
}

########################################################################
sub get_dependencies {
########################################################################
  my ($options) = @_;

  my $root = $options->{destdir} . '/src/main/perl/lib';

  my @perl_modules;

  croak q{this doesn't look much like a project directory}
    if !-d $root;

  @perl_modules = find_files( $root, 'pm', $FALSE );

  my $dirs = get_subdirs($root);

  my $all_dependencies
    = eval { return find_local_dependencies( [@perl_modules], $root ); };

  croak "error gathering dependencies: $EVAL_ERROR"
    if !$all_dependencies || $EVAL_ERROR;

  DEBUG Dumper( [ 'dependencies', $all_dependencies ] );

  return $all_dependencies->{modules};
}

########################################################################
sub makefile_am_list {
########################################################################
  my ( $file_list, $dir ) = @_;

  return $EMPTY if !ref $file_list || !@{$file_list};

  my @files = @{$file_list};

  if ($dir) {
    @files = map {"$dir/$_"} @files;
  }

  my $list = join " \\\n    ", @files;

  return "\\\n    " . $list;
}

########################################################################
sub find_resources {
########################################################################
  my ($root) = @_;

  my @resources;

  find(
    sub {
      return if /^Makefile/xsm || -d $File::Find::name;

      push @resources, basename $File::Find::name;
    },
    "$root/resources"
  );

  return \@resources;
}

########################################################################
sub init_parameters {
########################################################################
  my ($options) = @_;

  my @now = localtime;
  $now[5] += 1900;
  $now[4] += 1;

  my %timestamp = timestamp();

  $options->{date}      = $timestamp{date};
  $options->{timestamp} = $timestamp{timestamp};

  # Fri Feb 10 14:16:12 2023
  $options->{version}   = '@PACKAGE_VERSION@';   ## no critic (RequireInterpolation)
  $options->{generator} = basename $PROGRAM_NAME;

  # convenience routines for TT
  # creates a list that looks like this:
  # FOO = \
  #     ITEM \
  #     ITEM \
  #     ITEM
  $options->{makefile_am_list} = \&makefile_am_list;

  if ( $options->{refresh} ) {
    # main() prepped 'destdir', 'project' for refresh option from
    # abs_top_srcdir in Makefile, so we should be certain that root
    # for refresh is correct...
    my $root = sprintf '%s/%s', $options->{destdir}, $options->{project};

    $options->{resources} = find_resources($root);

    # refresh the list of files for 'built' assets look for .in files
    # in each directory, presumably someone dropped a new .in file in
    # one of these and wants to refresh the Makefile.am
    $options->{bash_scripts}
      = [ find_files( "$root/src/main/bash/bin", 'sh', $TRUE ) ];

    $options->{perl_scripts}
      = [ find_files( "$root/src/main/perl/bin", 'pl', $TRUE ) ];

    $options->{cgi_scripts}
      = [ find_files( "$root/src/main/perl/cgi-bin", 'pl', $TRUE ) ];

    DEBUG Dumper(
      [ 'refreshing',
        @{$options}{qw(bash_scripts perl_scripts cgi_scripts resources)}
      ]
    );

    for my $script_type (qw(bash perl cgi)) {
      $options->{ $script_type . '_scripts' }
        = [ map { ( basename $_) . '.in' }
          @{ $options->{ $script_type . '_scripts' } } ];
    }

    DEBUG Dumper(
      [ 'refreshed',
        @{$options}{qw(bash_scripts perl_scripts cgi_scripts resources)}
      ]
    );

    # find all config files...we may have a new file here too
    my @config_files;

    foreach ( values %CONFIG_FILE_EXTENSIONS ) {
      push @config_files, find_files( "$root/config", $_, $TRUE );
    }

    init_config_sections( $options, \@config_files );

    DEBUG Dumper( [ 'config sections', \@config_files, $options ] );
  }
  else {
    my $manifest = $options->{manifest};

    $options->{author}  //= $manifest->{author};
    $options->{email}   //= $manifest->{email};
    $options->{project} //= $manifest->{project};

    $options->{description} = $manifest->{description};

    my @file_lists = (
      bash_scripts     => $manifest->{bash}->{bin},
      perl_scripts     => $manifest->{perl}->{bin},
      cgi_scripts      => $manifest->{perl}->{'cgi-bin'},
      html_files       => $manifest->{html}->{htdocs},
      javascript_files => $manifest->{html}->{javascript},
      css_files        => $manifest->{html}->{css},
      image_files      => $manifest->{html}->{images},
      resources        => $manifest->{resources},
      config           => $manifest->{config},
    );

    # create arrays of just the file names from the source files
    for my $p ( pairs @file_lists ) {
      my ( $var, $list ) = @{$p};

      $list ||= [];

      $options->{$var} = [ map { basename $_ } @{$list} ];
    }

    $options->{perl_modules}
      = [ map { find_module_filename($_) } @{ $manifest->{perl}->{lib} } ];

    # create arrays for each config files type that will be used in
    # the config/Makefile.am template ('ini_files', 'cfg_files', etc)
    init_config_sections( $options, $options->{manifest}->{config} );
  }

  # defaults
  $options->{email}   //= $ENV{EMAIL} // 'anonymouse@example.com';
  $options->{author}  //= 'Anonymouse';
  $options->{project} //= 'noname';

  $options->{destdir} = sprintf '%s/%s', @{$options}{qw(destdir project)};

  return $options;
}

########################################################################
sub init_config_sections {
########################################################################
  my ( $options, $configs ) = @_;

  return $options
    if !ref $configs || !@{$configs};

  # find files of type .ini, .cfg, .json, .yaml and create a
  # parameter in the options hash for each type to be used by the
  # 'config/Makefile.am.tt' template
  #
  # [% ini_files %], e.g.
  #
  foreach my $p ( pairs %CONFIG_FILE_EXTENSIONS ) {
    my ( $type, $ext ) = @{$p};

    my @config_files = grep {/[.]$ext$/xsm} @{$configs};

    foreach (@config_files) {
      s/$/.in/xsm;
    }

    $options->{$type} = [@config_files];
  }

  return $options;
}

########################################################################
sub render_templates {
########################################################################
  my ($parameters) = @_;

  my $file_list = $parameters->{file_list};
  my $templates = $file_list->{templates};

  for my $template ( keys %{$templates} ) {

    if ( $parameters->{refresh} ) {
      next if none { $template eq $_ } @{ $file_list->{refresh} };
    }

    DEBUG 'rendering ' . $template;

    my ( $mode, $out )
      = ref $templates->{$template}
      ? @{ $templates->{$template} }
      : ( undef, $templates->{$template} );

    $out = sprintf '%s/%s', $parameters->{destdir}, $out;

    render_tt_template( $template, $parameters, $out );

    if ( defined $mode ) {
      chmod oct($mode), $out;
    }
  }

  return;
}

########################################################################
sub create_module_test_stub {
########################################################################
  my (%args) = @_;

  my ( $path, $file ) = @args{qw(path file)};

  my $module_name = path_to_module($file);

  my $test_name = lc $module_name;
  $test_name =~ s/::/-/xsmg;

  my $unit_test = sprintf '%s/t/00-%s.t', $path, $test_name;

  DEBUG sprintf 'rendering unit test %s to %s', $module_name, $unit_test;

  return render_tt_template( '00-module.t.tt', { module => $module_name },
    $unit_test );
}

########################################################################
sub create_script_test_stub {
########################################################################
  my (%args) = @_;

  my ( $file, $path ) = @args{qw(file path)};

  $file = basename $file;
  $file =~ s/[.]pl[.]in$//xsm;

  my $unit_test = sprintf '%s/t/00-%s.t', $path, $file;

  DEBUG sprintf 'rendering unit test %s to %s', $file, $unit_test;

  return render_tt_template( '00-script.t.tt', { script => $file },
    $unit_test );
}

########################################################################
sub create_unit_tests {
########################################################################
  my ( $options, $dependencies ) = @_;

  # create unit test scaffolding for .pm, .pl, and .cgi files
  my @unit_tests = (
    ( sprintf '%s/%s', $options->{destdir}, 'src/main/perl/lib' ) =>
      $options->{perl_modules},
    ( sprintf '%s/%s', $options->{destdir}, 'src/main/perl/bin' ) =>
      $options->{perl_scripts},
    ( sprintf '%s/%s', $options->{destdir}, 'src/main/perl/cgi-bin' ) =>
      $options->{cgi_scripts},
  );

  for my $p ( pairs @unit_tests ) {
    my ( $path, $files ) = @{$p};

    DEBUG Dumper( [ 'creating tests ', $path, $files ] );

    next if !$files || !@{$files};

    create_unit_test_stub(
      files => $files,
      path  => $path,
    );
  }

  return $options;
}

########################################################################
sub create_unit_test_stub {
########################################################################
  my (%args) = @_;

  my ( $files, $path ) = @args{qw(files path)};

  DEBUG Dumper( [ 'unit tests', $files, 'path', $path ] );

  foreach ( @{$files} ) {
    if (/[.]pm$/xsm) {
      create_module_test_stub( path => $path, file => $_ );
    }
    elsif (/[.]pl$/xsm) {
      create_script_test_stub( path => $path, file => $_ );
    }
  }

  return;
}

########################################################################
sub create_ax_requirements_check {
########################################################################
  my ($options) = @_;

  my $outfile = sprintf '%s/autotools/ax_requirements_check.m4',
    $options->{destdir};

  ## no critic (RequireInterpolationOfMetachars)
  return system '@bindir@/autoconf-ax-requirements-check.pl', '-r',
    $options->{destdir},
    '-o',
    $outfile;
}

########################################################################
sub create_changelog {
########################################################################
  my ($options) = @_;

  my @all_files;

  find(
    sub {
      return if -d $_;
      push @all_files, $File::Find::name;
    },
    $options->{destdir}
  );

  for (@all_files) {
    s/^\/?$options->{destdir}\///xsm;
  }

  render_tt_template(
    'ChangeLog.tt',
    { %{$options}, files => [ sort { lc $a cmp lc $b } @all_files ] },
    sprintf '%s/%s',
    $options->{destdir}, 'ChangeLog'
  );

  return;
}

########################################################################
sub do_subst {
########################################################################
  my ( $arg, $parameters ) = @_;

  DEBUG "do_subst($arg)";

  while ( $arg =~ /\@([^\@]+)\@/xsm ) {
    DEBUG "found substitution var $1";

    die "$1 is not defined in your parameter list\n"
      if !exists $parameters->{$1};

    my $val = $parameters->{$1};
    $arg =~ s/\@$1\@/$val/xsmg;

    DEBUG "arg now [$arg]";
  }

  return $arg;
}

########################################################################
sub copy_list {
########################################################################
  my ($options) = @_;

  my $destdir   = $options->{destdir};
  my $file_list = $options->{file_list}->{files};

  TRACE Dumper($options);

  foreach my $file ( keys %{$file_list} ) {
    my $dest = $destdir;

    my ( $mode, $out )
      = ref $file_list->{$file}
      ? @{ $file_list->{$file} }
      : ( undef, $file_list->{$file} );

    $out ||= $file;
    $out = do_subst( $out, $options );

    if ( $out =~ /\/$/xsm ) {
      $dest = sprintf '%s/%s/%s', $destdir, $out, $file;
    }
    else {
      $dest = sprintf '%s/%s', $destdir, $out;
    }

    create_path($dest);

    TRACE sprintf 'copying %s to %s', "$PROJECT_DIR/$file", $dest;

    croak "missing $file - perhaps you forgot to add it to Makefile.am?\n"
      if !-e "$PROJECT_DIR/$file";

    copy( "$PROJECT_DIR/$file", $dest );

    if ( defined $mode ) {
      TRACE sprintf 'chmod %s, %s', $mode, $dest;
      chmod oct($mode), $dest;
    }
  }

  return;
}

########################################################################
sub create_dependency_tree {
########################################################################
  my ( $dirs, $all_dependencies, $root ) = @_;

  my @modules;

  foreach my $dir ( sort keys %{$dirs} ) {
    my %module;

    my $path = $dir;
    $path =~ s{$root/?}{}xsm;

    $module{path} = $path;

    my $list = $dirs->{$dir};

    $module{list} = [];

    foreach my $file ( @{$list} ) {
      push @{ $module{list} }, $path ? "$path/$file" : $file;
    }

    my $module_name = $path;
    $module_name =~ s/\///xsm;
    $module{name_uc} = uc $module_name || 'PERL';
    $module{name_lc} = lc $module_name;

    $module{files}        = $list;
    $module{dependencies} = {};

    foreach my $file ( @{$list} ) {
      my $dependencies = [];

      DEBUG 'looking for ' . $path . $SLASH . $file;

      my $dep_file = $path . $SLASH . $file;
      $dep_file = strip_in($dep_file);
      $dep_file =~ s/^\///xsm;

      my @local_dependencies
        = @{ $all_dependencies->{$dep_file} || [] };

      next if !@local_dependencies;

      for my $dependency (@local_dependencies) {
        $dependency = strip_in($dependency);
        push @{$dependencies}, $dependency;
      }

      $module{dependencies}->{$file} = $dependencies;
    }

    push @modules, \%module;
  }

  return \@modules;
}

1;

__END__
